// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1.2 effective-5.10 (swiftlang-6.1.2.1.2 clang-1700.0.13.5)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-upcoming-feature StrictConcurrency -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name RealmSwift
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1.2
import AuthenticationServices
import Combine
import CoreLocation
import Foundation
import Realm.Private
import Realm.Swift
import Realm
import Swift
import Swift
import SwiftUI
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
public typealias PropertyType = RLMPropertyType
public typealias NotificationToken = RLMNotificationToken
public typealias ObjectBase = RLMObjectBase
public enum AnyRealmValue : Swift.Hashable {
  case none
  case int(Swift.Int)
  case bool(Swift.Bool)
  case float(Swift.Float)
  case double(Swift.Double)
  case string(Swift.String)
  case data(Foundation.Data)
  case date(Foundation.Date)
  case object(RealmSwift.Object)
  case objectId(RealmSwift.ObjectId)
  case decimal128(RealmSwift.Decimal128)
  case uuid(Foundation.UUID)
  case dictionary(RealmSwift.Map<Swift.String, RealmSwift.AnyRealmValue>)
  case list(RealmSwift.List<RealmSwift.AnyRealmValue>)
  public var intValue: Swift.Int? {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public var floatValue: Swift.Float? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public var dataValue: Foundation.Data? {
    get
  }
  public var dateValue: Foundation.Date? {
    get
  }
  public var objectIdValue: RealmSwift.ObjectId? {
    get
  }
  public var decimal128Value: RealmSwift.Decimal128? {
    get
  }
  public var uuidValue: Foundation.UUID? {
    get
  }
  public func object<T>(_ objectType: T.Type) -> T? where T : RealmSwiftObject
  public var dictionaryValue: RealmSwift.Map<Swift.String, RealmSwift.AnyRealmValue>? {
    get
  }
  public var listValue: RealmSwift.List<RealmSwift.AnyRealmValue>? {
    get
  }
  public var dynamicObject: RealmSwift.DynamicObject? {
    get
  }
  public init()
  public static func fromDictionary(_ dictionary: Swift.Dictionary<Swift.String, RealmSwift.AnyRealmValue>) -> RealmSwift.AnyRealmValue
  public static func fromArray(_ array: Swift.Array<RealmSwift.AnyRealmValue>) -> RealmSwift.AnyRealmValue
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RealmSwift.AnyRealmValue, b: RealmSwift.AnyRealmValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public typealias AppConfiguration = RLMAppConfiguration
extension RLMAppConfiguration {
  @available(*, deprecated, message: "localAppName and localAppVersion are not used for anything and should not be supplied")
  convenience public init(baseURL: Swift.String? = nil, transport: RLMNetworkTransport? = nil, localAppName: Swift.String?, localAppVersion: Swift.String?, defaultRequestTimeoutMS: Swift.UInt? = nil, enableSessionMultiplexing: Swift.Bool? = nil, syncTimeouts: RealmSwift.SyncTimeoutOptions? = nil)
  @_disfavoredOverload convenience public init(baseURL: Swift.String? = nil, transport: RLMNetworkTransport? = nil, defaultRequestTimeoutMS: Swift.UInt? = nil, enableSessionMultiplexing: Swift.Bool? = nil, syncTimeouts: RealmSwift.SyncTimeoutOptions? = nil)
}
public typealias APIKeyAuth = RLMAPIKeyAuth
public typealias EmailPasswordAuth = RLMEmailPasswordAuth
public typealias UserProfile = RLMUserProfile
extension RLMUserProfile {
  public var metadata: RealmSwift.Document {
    get
  }
}
public typealias EmailPasswordAuthOptionalErrorBlock = RLMEmailPasswordAuthOptionalErrorBlock
extension RLMEmailPasswordAuth {
  public func callResetPasswordFunction(email: Swift.String, password: Swift.String, args: [RealmSwift.AnyBSON], _ completion: @escaping RealmSwift.EmailPasswordAuthOptionalErrorBlock)
  @available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, *)
  public func callResetPasswordFunction(email: Swift.String, password: Swift.String, args: [RealmSwift.AnyBSON]) -> Combine.Future<Swift.Void, any Swift.Error>
  @available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, *)
  public func callResetPasswordFunction(email: Swift.String, password: Swift.String, args: [RealmSwift.AnyBSON]) async throws
}
public typealias PushClient = RLMPushClient
public typealias UserAPIKey = RLMUserAPIKey
extension RLMUserAPIKey {
  public var objectId: RealmSwift.ObjectId {
    get
  }
}
@frozen public enum Credentials : Swift.Sendable {
  case facebook(accessToken: Swift.String)
  case google(serverAuthCode: Swift.String)
  case googleId(token: Swift.String)
  case apple(idToken: Swift.String)
  case emailPassword(email: Swift.String, password: Swift.String)
  case jwt(token: Swift.String)
  case function(payload: RealmSwift.Document)
  case userAPIKey(Swift.String)
  case serverAPIKey(Swift.String)
  case anonymous
}
public typealias App = RLMApp
extension RLMApp {
  @_spi(RealmSwiftExperimental) @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func updateBaseUrl(to url: Swift.String?, _ completion: @escaping @Sendable ((any Swift.Error)?) -> Swift.Void)
  @_spi(RealmSwiftExperimental) @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func updateBaseUrl(to url: Swift.String?) -> Combine.Future<Swift.Void, any Swift.Error>
  @preconcurrency public func login(credentials: RealmSwift.Credentials, _ completion: @escaping @Sendable (Swift.Result<RealmSwift.User, any Swift.Error>) -> Swift.Void)
  @_spi(RealmSwiftExperimental) @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func updateBaseUrl(to url: Swift.String?, _ completion: @escaping @Sendable (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  @available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, *)
  public func login(credentials: RealmSwift.Credentials) -> Combine.Future<RealmSwift.User, any Swift.Error>
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func login(credentials: RealmSwift.Credentials) async throws -> RealmSwift.User
  @_spi(RealmSwiftExperimental) @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func updateBaseUrl(to url: Swift.String?) async throws
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias ASLoginDelegate = RLMASLoginDelegate
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMApp {
  public func setASAuthorizationControllerDelegate(for controller: AuthenticationServices.ASAuthorizationController)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AppSubscription : Combine.Subscription {
  private let token: RLMAppSubscriptionToken
  public var combineIdentifier: Combine.CombineIdentifier {
    get
  }
  public func request(_ demand: Combine.Subscribers.Demand)
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public struct AppPublisher : Combine.Publisher, @unchecked Swift.Sendable {
  public typealias Failure = Swift.Never
  public typealias Output = RealmSwift.App
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S : Swift.Sendable, S.Failure == Swift.Never, S.Input == RLMApp
  public func receive<S>(on scheduler: S) -> RealmSwift.AppPublisher where S : Combine.Scheduler
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMApp {
  public var objectWillChange: RealmSwift.AppPublisher {
    get
  }
}
extension RLMApp : @retroactive Combine.ObservableObject {
  public typealias ObjectWillChangePublisher = RealmSwift.AppPublisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMEmailPasswordAuth {
  public func registerUser(email: Swift.String, password: Swift.String) -> Combine.Future<Swift.Void, any Swift.Error>
  public func confirmUser(_ token: Swift.String, tokenId: Swift.String) -> Combine.Future<Swift.Void, any Swift.Error>
  public func resendConfirmationEmail(email: Swift.String) -> Combine.Future<Swift.Void, any Swift.Error>
  public func retryCustomConfirmation(email: Swift.String) -> Combine.Future<Swift.Void, any Swift.Error>
  public func sendResetPasswordEmail(email: Swift.String) -> Combine.Future<Swift.Void, any Swift.Error>
  public func resetPassword(to: Swift.String, token: Swift.String, tokenId: Swift.String) -> Combine.Future<Swift.Void, any Swift.Error>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMAPIKeyAuth {
  public func createAPIKey(named: Swift.String) -> Combine.Future<RealmSwift.UserAPIKey, any Swift.Error>
  public func fetchAPIKey(_ objectId: RealmSwift.ObjectId) -> Combine.Future<RealmSwift.UserAPIKey, any Swift.Error>
  public func fetchAPIKeys() -> Combine.Future<[RealmSwift.UserAPIKey], any Swift.Error>
  public func deleteAPIKey(_ objectId: RealmSwift.ObjectId) -> Combine.Future<Swift.Void, any Swift.Error>
  public func enableAPIKey(_ objectId: RealmSwift.ObjectId) -> Combine.Future<Swift.Void, any Swift.Error>
  public func disableAPIKey(_ objectId: RealmSwift.ObjectId) -> Combine.Future<Swift.Void, any Swift.Error>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMPushClient {
  public func registerDevice(token: Swift.String, user: RealmSwift.User) -> Combine.Future<Swift.Void, any Swift.Error>
  public func deregisterDevice(user: RealmSwift.User) -> Combine.Future<Swift.Void, any Swift.Error>
}
extension RLMAPIKeyAuth {
  @preconcurrency public func createAPIKey(named: Swift.String, completion: @escaping @Sendable (Swift.Result<RealmSwift.UserAPIKey, any Swift.Error>) -> Swift.Void)
  @preconcurrency public func fetchAPIKey(_ objectId: RealmSwift.ObjectId, _ completion: @escaping @Sendable (Swift.Result<RealmSwift.UserAPIKey, any Swift.Error>) -> Swift.Void)
  @preconcurrency public func fetchAPIKeys(_ completion: @escaping @Sendable (Swift.Result<[RealmSwift.UserAPIKey], any Swift.Error>) -> Swift.Void)
}
public typealias AsymmetricObject = RealmSwiftAsymmetricObject
extension RealmSwiftAsymmetricObject {
  convenience public init(value: Any)
  public var objectSchema: RealmSwift.ObjectSchema {
    get
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc override public static func _getProperties() -> [RLMProperty]
  @objc override dynamic open class func propertiesMapping() -> [Swift.String : Swift.String]
  @available(*, unavailable, renamed: "propertiesMapping", message: "`_realmColumnNames` private API is unavailable in our Swift SDK, please use the override `.propertiesMapping()` instead.")
  @objc override dynamic open class func _realmColumnNames() -> [Swift.String : Swift.String]
  @objc dynamic open subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set
  }
}
extension Swift.Int {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Int8 {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Int16 {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Int32 {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Int64 {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Bool {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Float {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Double {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.String {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Foundation.Data {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension RealmSwift.ObjectId {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension RealmSwift.Decimal128 {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Foundation.Date {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Foundation.UUID {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension RealmSwift.AnyRealmValue {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension Foundation.NSString {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Foundation.NSData {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Foundation.NSDate {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
extension Swift.Int {
  public typealias PersistedType = Swift.Int
}
extension Swift.Int8 {
  public typealias PersistedType = Swift.Int8
}
extension Swift.Int16 {
  public typealias PersistedType = Swift.Int16
}
extension Swift.Int32 {
  public typealias PersistedType = Swift.Int32
}
extension Swift.Int64 {
  public typealias PersistedType = Swift.Int64
}
extension Swift.Bool : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible, RealmSwift._PrimaryKey, RealmSwift._Indexable {
  public typealias PersistedType = Swift.Bool
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.Bool {
        return RLMGetSwiftPropertyBool(obj, key)
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.Bool? {
        var gotValue = false
        let ret = RLMGetSwiftPropertyBoolOptional(obj, key, &gotValue)
        return gotValue ? ret : nil
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Swift.Bool) {
        RLMSetSwiftPropertyBool(obj, key, (value))
    }
}
extension Swift.Float : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible {
  public typealias PersistedType = Swift.Float
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.Float {
        return RLMGetSwiftPropertyFloat(obj, key)
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.Float? {
        var gotValue = false
        let ret = RLMGetSwiftPropertyFloatOptional(obj, key, &gotValue)
        return gotValue ? ret : nil
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Swift.Float) {
        RLMSetSwiftPropertyFloat(obj, key, (value))
    }
}
extension Swift.Double : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible {
  public typealias PersistedType = Swift.Double
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.Double {
        return RLMGetSwiftPropertyDouble(obj, key)
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.Double? {
        var gotValue = false
        let ret = RLMGetSwiftPropertyDoubleOptional(obj, key, &gotValue)
        return gotValue ? ret : nil
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Swift.Double) {
        RLMSetSwiftPropertyDouble(obj, key, (value))
    }
}
extension Swift.String : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible, RealmSwift._PrimaryKey, RealmSwift._Indexable {
  public typealias PersistedType = Swift.String
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.String {
        return RLMGetSwiftPropertyString(obj, key)!
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Swift.String? {
        return RLMGetSwiftPropertyString(obj, key)
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Swift.String) {
        RLMSetSwiftPropertyString(obj, key, value)
    }
}
extension Foundation.Data : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible {
  public typealias PersistedType = Foundation.Data
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Foundation.Data {
        return RLMGetSwiftPropertyData(obj, key)!
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Foundation.Data? {
        return RLMGetSwiftPropertyData(obj, key)
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Foundation.Data) {
        RLMSetSwiftPropertyData(obj, key, value)
    }
}
extension RealmSwift.ObjectId : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible, RealmSwift._PrimaryKey, RealmSwift._Indexable {
  public typealias PersistedType = RealmSwift.ObjectId
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> RealmSwift.ObjectId {
        return RLMGetSwiftPropertyObjectId(obj, key) as! ObjectId
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> RealmSwift.ObjectId? {
        return RLMGetSwiftPropertyObjectId(obj, key).flatMap(failableStaticBridgeCast)
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: RealmSwift.ObjectId) {
        RLMSetSwiftPropertyObjectId(obj, key, (value))
    }
  public static func _rlmDefaultValue() -> RealmSwift.ObjectId
}
extension RealmSwift.Decimal128 : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible {
  public typealias PersistedType = RealmSwift.Decimal128
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> RealmSwift.Decimal128 {
        return RLMGetSwiftPropertyDecimal128(obj, key) as! Decimal128
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> RealmSwift.Decimal128? {
        return RLMGetSwiftPropertyDecimal128(obj, key).flatMap(failableStaticBridgeCast)
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: RealmSwift.Decimal128) {
        RLMSetSwiftPropertyDecimal128(obj, key, value)
    }
}
extension Foundation.Date : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible, RealmSwift._Indexable {
  public typealias PersistedType = Foundation.Date
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Foundation.Date {
        return RLMGetSwiftPropertyDate(obj, key)!
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Foundation.Date? {
        return RLMGetSwiftPropertyDate(obj, key)
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Foundation.Date) {
        RLMSetSwiftPropertyDate(obj, key, value)
    }
}
extension Foundation.UUID : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible, RealmSwift._PrimaryKey, RealmSwift._Indexable {
  public typealias PersistedType = Foundation.UUID
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Foundation.UUID {
        return RLMGetSwiftPropertyUUID(obj, key)!
    }
  @inlinable public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Foundation.UUID? {
        return RLMGetSwiftPropertyUUID(obj, key)
    }
  @inlinable public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Foundation.UUID) {
        RLMSetSwiftPropertyUUID(obj, key, value)
    }
}
extension RealmSwift.AnyRealmValue : RealmSwift._Persistable, RealmSwift._DefaultConstructible {
  public typealias PersistedType = RealmSwift.AnyRealmValue
  @inlinable public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> RealmSwift.AnyRealmValue {
        return ObjectiveCSupport.convert(value: RLMGetSwiftPropertyAny(obj, key))
    }
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: RealmSwift.AnyRealmValue)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
public protocol PartitionValue : Swift.Sendable {
}
public protocol BSON : RealmSwift.PartitionValue, Swift.Equatable {
}
extension Foundation.NSNull : RealmSwift.BSON {
}
extension Swift.Int : RealmSwift.BSON {
}
extension Swift.Int32 : RealmSwift.BSON {
}
extension Swift.Int64 : RealmSwift.BSON {
}
extension Swift.Bool : RealmSwift.BSON {
}
extension Swift.Double : RealmSwift.BSON {
}
extension Swift.String : RealmSwift.BSON {
}
extension Foundation.Data : RealmSwift.BSON {
}
extension Foundation.Date : RealmSwift.BSON {
}
extension RealmSwift.Decimal128 : RealmSwift.BSON {
}
extension RealmSwift.ObjectId : RealmSwift.BSON {
}
extension Foundation.UUID : RealmSwift.BSON {
}
public typealias Document = Swift.Dictionary<Swift.String, RealmSwift.AnyBSON?>
extension Swift.Dictionary : RealmSwift.BSON, RealmSwift.PartitionValue where Key == Swift.String, Value == RealmSwift.AnyBSON? {
}
extension Swift.Array : RealmSwift.BSON, RealmSwift.PartitionValue where Element == RealmSwift.AnyBSON? {
}
extension Foundation.NSRegularExpression : RealmSwift.BSON {
}
public typealias MaxKey = RLMMaxKey
extension RLMMaxKey : RealmSwift.BSON {
}
public typealias MinKey = RLMMinKey
extension RLMMinKey : RealmSwift.BSON {
}
@frozen public enum AnyBSON : RealmSwift.BSON, Swift.Sendable {
  case double(Swift.Double)
  case string(Swift.String)
  indirect case document(RealmSwift.Document)
  indirect case array([RealmSwift.AnyBSON?])
  case binary(Foundation.Data)
  case objectId(RealmSwift.ObjectId)
  case bool(Swift.Bool)
  case datetime(Foundation.Date)
  case regex(Foundation.NSRegularExpression)
  case int32(Swift.Int32)
  case timestamp(Foundation.Date)
  case int64(Swift.Int64)
  case decimal128(RealmSwift.Decimal128)
  case uuid(Foundation.UUID)
  case minKey
  case maxKey
  case null
  public init(_ int: Swift.Int)
  public init<T>(_ bson: T) where T : RealmSwift.BSON
  public var int32Value: Swift.Int32? {
    get
  }
  public var regexValue: Foundation.NSRegularExpression? {
    get
  }
  public var int64Value: Swift.Int64? {
    get
  }
  public var objectIdValue: RealmSwift.ObjectId? {
    get
  }
  public var dateValue: Foundation.Date? {
    get
  }
  public var arrayValue: [RealmSwift.AnyBSON?]? {
    get
  }
  public var stringValue: Swift.String? {
    get
  }
  public var documentValue: RealmSwift.Document? {
    get
  }
  public var boolValue: Swift.Bool? {
    get
  }
  public var binaryValue: Foundation.Data? {
    get
  }
  public var doubleValue: Swift.Double? {
    get
  }
  public var decimal128Value: RealmSwift.Decimal128? {
    get
  }
  public var timestampValue: Foundation.Date? {
    get
  }
  public var uuidValue: Foundation.UUID? {
    get
  }
  public var isNull: Swift.Bool {
    get
  }
  public func asInt() -> Swift.Int?
  public func asInt32() -> Swift.Int32?
  public func asInt64() -> Swift.Int64?
  public func asDouble() -> Swift.Double?
  public func asDecimal128() -> RealmSwift.Decimal128?
  public func value<T>() -> T? where T : RealmSwift.BSON
}
extension RealmSwift.AnyBSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension RealmSwift.AnyBSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension RealmSwift.AnyBSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension RealmSwift.AnyBSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension RealmSwift.AnyBSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, RealmSwift.AnyBSON?)...)
  public typealias Key = Swift.String
  public typealias Value = RealmSwift.AnyBSON?
}
extension RealmSwift.AnyBSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: RealmSwift.AnyBSON?...)
  public typealias ArrayLiteralElement = RealmSwift.AnyBSON?
}
extension RealmSwift.AnyBSON : Swift.Equatable {
  public static func == (a: RealmSwift.AnyBSON, b: RealmSwift.AnyBSON) -> Swift.Bool
}
extension RealmSwift.AnyBSON : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public protocol ObjectKeyIdentifiable : Swift.Identifiable {
  var id: Swift.UInt64 { get }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
@available(*, deprecated, renamed: "ObjectKeyIdentifiable")
public typealias ObjectKeyIdentifable = RealmSwift.ObjectKeyIdentifiable
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension RealmSwift.ObjectKeyIdentifiable where Self : RLMObjectBase {
  public var id: Swift.UInt64 {
    get
  }
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension RealmSwift.ObjectKeyIdentifiable where Self : RealmSwift.ProjectionObservable {
  public var id: Swift.UInt64 {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public protocol RealmSubscribable {
  func _observe<S>(_ keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue?, _ subscriber: S) -> RealmSwift.NotificationToken where Self == S.Input, S : Combine.Subscriber
  func _observe<S>(_ keyPaths: [Swift.String]?, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func freeze<T>() -> Combine.Publishers.Map<Self, T> where T : RealmSwift.ThreadConfined, T == Self.Output
  public func freeze<T>() -> Combine.Publishers.Map<Self, RealmSwift.ObjectChange<T>> where T : RealmSwiftObject, Self.Output == RealmSwift.ObjectChange<T>
  public func freeze<T>() -> Combine.Publishers.Map<Self, RealmSwift.RealmCollectionChange<T>> where T : RealmSwift.RealmCollection, Self.Output == RealmSwift.RealmCollectionChange<T>
  public func freeze<T>() -> Combine.Publishers.Map<Self, RealmSwift.SectionedResultsChange<T>> where T : RealmSwift.RealmSectionedResult, Self.Output == RealmSwift.SectionedResultsChange<T>
  public func freeze<T>() -> Combine.Publishers.Map<Self, RealmSwift.RealmMapChange<T>> where T : RealmSwift.RealmKeyedCollection, Self.Output == RealmSwift.RealmMapChange<T>
  public func freeze<T>() -> Combine.Publishers.Map<Self, RealmSwift.ObjectChange<T>> where T : RealmSwift.ProjectionObservable, Self.Output == RealmSwift.ObjectChange<T>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher where Self.Output : RealmSwift.ThreadConfined {
  public func threadSafeReference() -> RealmSwift.RealmPublishers.MakeThreadSafe<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publisher {
  public func threadSafeReference<T>() -> RealmSwift.RealmPublishers.MakeThreadSafeObjectChangeset<Self, T> where T : RealmSwiftObject, Self.Output == RealmSwift.ObjectChange<T>
  public func threadSafeReference<T>() -> RealmSwift.RealmPublishers.MakeThreadSafeObjectChangeset<Self, T> where T : RealmSwift.ProjectionObservable, Self.Output == RealmSwift.ObjectChange<T>
  public func threadSafeReference<T>() -> RealmSwift.RealmPublishers.MakeThreadSafeCollectionChangeset<Self, T> where T : RealmSwift.RealmCollection, Self.Output == RealmSwift.RealmCollectionChange<T>
  public func threadSafeReference<T>() -> RealmSwift.RealmPublishers.MakeThreadSafeKeyedCollectionChangeset<Self, T> where T : RealmSwift.RealmKeyedCollection, Self.Output == RealmSwift.RealmMapChange<T>
  public func threadSafeReference<T>() -> RealmSwift.RealmPublishers.MakeThreadSafeSectionedResultsChangeset<Self, T> where T : RealmSwift.RealmSectionedResult, Self.Output == RealmSwift.SectionedResultsChange<T>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.RealmCollection where Self : RealmSwift.RealmSubscribable {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<Self> {
    get
  }
  @available(*, deprecated, renamed: "collectionPublisher")
  public var publisher: RealmSwift.RealmPublishers.Value<Self> {
    get
  }
  public var collectionPublisher: RealmSwift.RealmPublishers.Value<Self> {
    get
  }
  public func collectionPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.Value<Self>
  public var changesetPublisher: RealmSwift.RealmPublishers.CollectionChangeset<Self> {
    get
  }
  public func changesetPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.CollectionChangeset<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.RealmKeyedCollection where Self : RealmSwift.RealmSubscribable {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<Self> {
    get
  }
  @available(*, deprecated, renamed: "collectionPublisher")
  public var publisher: RealmSwift.RealmPublishers.Value<Self> {
    get
  }
  public var collectionPublisher: RealmSwift.RealmPublishers.Value<Self> {
    get
  }
  public func collectionPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.Value<Self>
  public var changesetPublisher: RealmSwift.RealmPublishers.MapChangeset<Self> {
    get
  }
  public func changesetPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.MapChangeset<Self>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func valuePublisher<T>(_ object: T, keyPaths: [Swift.String]? = nil) -> RealmSwift.RealmPublishers.Value<T> where T : RealmSwiftObject
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func valuePublisher<T>(_ collection: T, keyPaths: [Swift.String]? = nil) -> RealmSwift.RealmPublishers.Value<T> where T : RealmSwift.RealmCollection, T : RealmSwift.RealmSubscribable
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func valuePublisher<T>(_ projection: T, keyPaths: [Swift.String]? = nil) -> RealmSwift.RealmPublishers.Value<T> where T : RealmSwift.ProjectionObservable, T : RealmSwift.RealmSubscribable
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func changesetPublisher<T>(_ object: T, keyPaths: [Swift.String]? = nil) -> RealmSwift.RealmPublishers.ObjectChangeset<T> where T : RealmSwiftObject
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func changesetPublisher<T>(_ projection: T, keyPaths: [Swift.String]? = nil) -> RealmSwift.RealmPublishers.ObjectChangeset<T> where T : RealmSwift.ProjectionObservable
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public func changesetPublisher<T>(_ collection: T, keyPaths: [Swift.String]? = nil) -> RealmSwift.RealmPublishers.CollectionChangeset<T> where T : RealmSwift.RealmCollection
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Realm {
  public var objectWillChange: RealmSwift.RealmPublishers.RealmWillChange {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwiftObject {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.Object> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwiftEmbeddedObject {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.EmbeddedObject> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMObjectBase : RealmSwift.RealmSubscribable {
  public func _observe<S>(_ keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue?, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input : RLMObjectBase
  public func _observe<S>(_ keyPaths: [Swift.String]?, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwiftObject : @retroactive Combine.ObservableObject {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = RealmSwift.RealmPublishers.WillChange<RealmSwift.Object>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwiftEmbeddedObject : @retroactive Combine.ObservableObject {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = RealmSwift.RealmPublishers.WillChange<RealmSwift.EmbeddedObject>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.List : Combine.ObservableObject, RealmSwift.RealmSubscribable {
  final public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.List<Element>> {
    get
  }
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = RealmSwift.RealmPublishers.WillChange<RealmSwift.List<Element>>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.MutableSet : Combine.ObservableObject, RealmSwift.RealmSubscribable {
  final public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.MutableSet<Element>> {
    get
  }
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = RealmSwift.RealmPublishers.WillChange<RealmSwift.MutableSet<Element>>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Map : Combine.ObservableObject, RealmSwift.RealmSubscribable {
  final public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.Map<Key, Value>> {
    get
  }
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = RealmSwift.RealmPublishers.WillChange<RealmSwift.Map<Key, Value>>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.LinkingObjects : RealmSwift.RealmSubscribable {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.LinkingObjects<Element>> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Results : RealmSwift.RealmSubscribable {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.Results<Element>> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.SectionedResults : RealmSwift.RealmSubscribable {
  public func _observe<S>(_ keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == RealmSwift.SectionedResults<Key, SectionElement>
  public func _observe<S>(_ keyPaths: [Swift.String]? = nil, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.SectionedResults<Key, SectionElement>> {
    get
  }
  public var collectionPublisher: RealmSwift.RealmPublishers.Value<RealmSwift.SectionedResults<Key, SectionElement>> {
    get
  }
  public func collectionPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.Value<RealmSwift.SectionedResults<Key, SectionElement>>
  public var changesetPublisher: RealmSwift.RealmPublishers.SectionedResultsChangeset<RealmSwift.SectionedResults<Key, SectionElement>> {
    get
  }
  public func changesetPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.SectionedResultsChangeset<RealmSwift.SectionedResults<Key, SectionElement>>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ResultsSection : RealmSwift.RealmSubscribable {
  public func _observe<S>(_ keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == RealmSwift.ResultsSection<Key, T>
  public func _observe<S>(_ keyPaths: [Swift.String]? = nil, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.ResultsSection<Key, T>> {
    get
  }
  public var collectionPublisher: RealmSwift.RealmPublishers.Value<RealmSwift.ResultsSection<Key, T>> {
    get
  }
  public func collectionPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.Value<RealmSwift.ResultsSection<Key, T>>
  public var changesetPublisher: RealmSwift.RealmPublishers.SectionChangeset<RealmSwift.ResultsSection<Key, T>> {
    get
  }
  public func changesetPublisher(keyPaths: [Swift.String]?) -> RealmSwift.RealmPublishers.SectionChangeset<RealmSwift.ResultsSection<Key, T>>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.AnyRealmCollection : RealmSwift.RealmSubscribable {
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.RealmKeyedCollection {
  public func _observe<S>(_ keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue? = nil, _ subscriber: S) -> RealmSwift.NotificationToken where Self == S.Input, S : Combine.Subscriber
  public func _observe<S>(_ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
  public func _observe<S>(_ keyPaths: [Swift.String]? = nil, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@frozen public struct ObservationSubscription : Combine.Subscription {
  private var token: RealmSwift.NotificationToken
  public var combineIdentifier: Combine.CombineIdentifier {
    get
  }
  public func request(_ demand: Combine.Subscribers.Demand)
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@frozen public struct AsyncOpenSubscription : Combine.Subscription {
  private let task: RealmSwift.Realm.AsyncOpenTask
  public var combineIdentifier: Combine.CombineIdentifier {
    get
  }
  public func request(_ demand: Combine.Subscribers.Demand)
  public func cancel()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public enum RealmPublishers {
  @frozen public struct AsyncOpenPublisher : Combine.Publisher {
    public typealias Failure = Swift.Error
    public typealias Output = RealmSwift.Realm
    private let configuration: RealmSwift.Realm.Configuration
    private let callbackQueue: Dispatch.DispatchQueue
    private let onProgressNotificationCallback: ((RealmSwift.SyncSession.Progress) -> Swift.Void)?
    public func onProgressNotification(_ onProgressNotificationCallback: @escaping (RealmSwift.SyncSession.Progress) -> Swift.Void) -> RealmSwift.RealmPublishers.AsyncOpenPublisher
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == RealmSwift.Realm
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.AsyncOpenPublisher where S : Combine.Scheduler
  }
  @frozen public struct RealmWillChange : Combine.Publisher {
    public typealias Failure = Swift.Never
    public typealias Output = Swift.Void
    private let realm: RealmSwift.Realm
    public func saveToken<T>(on object: T, for keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.RealmWillChangeWithToken<T>
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ()
  }
  @_hasMissingDesignatedInitializers public class RealmWillChangeWithToken<T> : Combine.Publisher {
    public typealias Failure = Swift.Never
    public typealias Output = Swift.Void
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ()
    @objc deinit
  }
  @frozen public struct WillChange<Collection> : Combine.Publisher where Collection : RealmSwift.RealmSubscribable, Collection : RealmSwift.ThreadConfined {
    public typealias Failure = Swift.Never
    public typealias Output = Swift.Void
    private let collection: Collection
    public func saveToken<T>(on object: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.WillChangeWithToken<Collection, T>
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ()
  }
  @_hasMissingDesignatedInitializers public class WillChangeWithToken<Collection, T> : Combine.Publisher where Collection : RealmSwift.RealmSubscribable, Collection : RealmSwift.ThreadConfined {
    public typealias Failure = Swift.Never
    public typealias Output = Swift.Void
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == ()
    @objc deinit
  }
  @frozen public struct Value<Subscribable> : Combine.Publisher where Subscribable : RealmSwift.RealmSubscribable, Subscribable : RealmSwift.ThreadConfined {
    public typealias Failure = Swift.Error
    public typealias Output = Subscribable
    private let subscribable: Subscribable
    private let keyPaths: [Swift.String]?
    private let queue: Dispatch.DispatchQueue?
    public func saveToken<T>(on object: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.ValueWithToken<Subscribable, T>
    public func receive<S>(subscriber: S) where Subscribable == S.Input, S : Combine.Subscriber, S.Failure == any Swift.Error
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.Value<Subscribable> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.Handover<RealmSwift.RealmPublishers.Value<Subscribable>, S> where S : Combine.Scheduler
  }
  @_hasMissingDesignatedInitializers public class ValueWithToken<Subscribable, T> : Combine.Publisher where Subscribable : RealmSwift.RealmSubscribable, Subscribable : RealmSwift.ThreadConfined {
    public typealias Failure = Swift.Error
    public typealias Output = Subscribable
    public func receive<S>(subscriber: S) where Subscribable == S.Input, S : Combine.Subscriber, S.Failure == any Swift.Error
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.ValueWithToken<Subscribable, T> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.Handover<RealmSwift.RealmPublishers.ValueWithToken<Subscribable, T>, S> where S : Combine.Scheduler
    @objc deinit
  }
  @frozen public struct Handover<Upstream, S> : Combine.Publisher where Upstream : Combine.Publisher, S : Combine.Scheduler, Upstream.Output : RealmSwift.ThreadConfined {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let config: RLMRealmConfiguration
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Upstream.Output == Sub.Input
  }
  @frozen public struct MakeThreadSafe<Upstream> : Combine.Publisher where Upstream : Combine.Publisher, Upstream.Output : RealmSwift.ThreadConfined {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, Upstream.Output == S.Input
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandover<Upstream, S> where S : Combine.Scheduler
  }
  @frozen public struct DeferredHandover<Upstream, S> : Combine.Publisher where Upstream : Combine.Publisher, S : Combine.Scheduler, Upstream.Output : RealmSwift.ThreadConfined {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Upstream.Output == Sub.Input
  }
  @frozen public struct ObjectChangeset<O> : Combine.Publisher where O : RealmSwift.ThreadConfined {
    public typealias Output = RealmSwift.ObjectChange<O>
    public typealias Failure = Swift.Never
    @usableFromInline
    internal typealias Observe = (_ queue: Dispatch.DispatchQueue?, @escaping (RealmSwift.RealmPublishers.ObjectChangeset<O>.Output) -> Swift.Void) -> RealmSwift.NotificationToken
    private let observe: RealmSwift.RealmPublishers.ObjectChangeset<O>.Observe
    private let queue: Dispatch.DispatchQueue?
    public func saveToken<T>(on tokenParent: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.ObjectChangesetWithToken<O, T> where O : RealmSwiftObject
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.ObjectChange<O>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.ObjectChangeset<O> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverObjectChangeset<RealmSwift.RealmPublishers.ObjectChangeset<O>, O, S> where S : Combine.Scheduler
  }
  @_hasMissingDesignatedInitializers public class ObjectChangesetWithToken<O, T> : Combine.Publisher where O : RealmSwiftObject {
    public typealias Output = RealmSwift.ObjectChange<O>
    public typealias Failure = Swift.Never
    @usableFromInline
    internal typealias Observe = (_ queue: Dispatch.DispatchQueue?, @escaping (RealmSwift.RealmPublishers.ObjectChangesetWithToken<O, T>.Output) -> Swift.Void) -> RealmSwift.NotificationToken
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.ObjectChange<O>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.ObjectChangesetWithToken<O, T> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverObjectChangeset<RealmSwift.RealmPublishers.ObjectChangesetWithToken<O, T>, T, S> where O == T, S : Combine.Scheduler
    @objc deinit
  }
  @frozen public struct MakeThreadSafeObjectChangeset<Upstream, T> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.ThreadConfined, Upstream.Output == RealmSwift.ObjectChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, S.Input == RealmSwift.ObjectChange<T>
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverObjectChangeset<Upstream, T, S> where S : Combine.Scheduler
  }
  @frozen public struct DeferredHandoverObjectChangeset<Upstream, T, S> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.ThreadConfined, S : Combine.Scheduler, Upstream.Output == RealmSwift.ObjectChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Sub.Input == RealmSwift.ObjectChange<T>
  }
  @frozen public struct CollectionChangeset<Collection> : Combine.Publisher where Collection : RealmSwift.RealmCollection {
    public typealias Output = RealmSwift.RealmCollectionChange<Collection>
    public typealias Failure = Swift.Never
    private let collection: Collection
    private let keyPaths: [Swift.String]?
    private let queue: Dispatch.DispatchQueue?
    public func saveToken<T>(on object: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.CollectionChangesetWithToken<Collection, T>
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.RealmCollectionChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.CollectionChangeset<Collection> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverCollectionChangeset<RealmSwift.RealmPublishers.CollectionChangeset<Collection>, Collection, S> where S : Combine.Scheduler
  }
  @frozen public struct MapChangeset<Collection> : Combine.Publisher where Collection : RealmSwift.RealmKeyedCollection {
    public typealias Output = RealmSwift.RealmMapChange<Collection>
    public typealias Failure = Swift.Never
    private let collection: Collection
    private let keyPaths: [Swift.String]?
    private let queue: Dispatch.DispatchQueue?
    public func saveToken<T>(on object: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.MapChangesetWithToken<Collection, T>
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.RealmMapChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.MapChangeset<Collection> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverKeyedCollectionChangeset<RealmSwift.RealmPublishers.MapChangeset<Collection>, Collection, S> where S : Combine.Scheduler
  }
  @frozen public struct SectionedResultsChangeset<Collection> : Combine.Publisher where Collection : RealmSwift.RealmSectionedResult {
    public typealias Output = RealmSwift.SectionedResultsChange<Collection>
    public typealias Failure = Swift.Never
    private let collection: Collection
    private let keyPaths: [Swift.String]?
    private let queue: Dispatch.DispatchQueue?
    public func saveToken<T>(on object: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.SectionedResultsChangesetWithToken<Collection, T>
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.SectionedResultsChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.SectionedResultsChangeset<Collection> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverSectionedResultsChangeset<RealmSwift.RealmPublishers.SectionedResultsChangeset<Collection>, Collection, S> where S : Combine.Scheduler
  }
  @frozen public struct SectionChangeset<Collection> : Combine.Publisher where Collection : RealmSwift.RealmSectionedResult {
    public typealias Output = RealmSwift.SectionedResultsChange<Collection>
    public typealias Failure = Swift.Never
    private let collection: Collection
    private let keyPaths: [Swift.String]?
    private let queue: Dispatch.DispatchQueue?
    public func saveToken<T>(on object: T, at keyPath: Swift.WritableKeyPath<T, RealmSwift.NotificationToken?>) -> RealmSwift.RealmPublishers.SectionedResultsChangesetWithToken<Collection, T>
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.SectionedResultsChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.SectionedResultsChangeset<Collection> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverSectionedResultsChangeset<RealmSwift.RealmPublishers.SectionChangeset<Collection>, Collection, S> where S : Combine.Scheduler
  }
  @_hasMissingDesignatedInitializers public class CollectionChangesetWithToken<Collection, T> : Combine.Publisher where Collection : RealmSwift.RealmCollection {
    public typealias Output = RealmSwift.RealmCollectionChange<Collection>
    public typealias Failure = Swift.Never
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.RealmCollectionChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.CollectionChangesetWithToken<Collection, T> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverCollectionChangeset<RealmSwift.RealmPublishers.CollectionChangesetWithToken<Collection, T>, Collection, S> where S : Combine.Scheduler
    @objc deinit
  }
  @_hasMissingDesignatedInitializers public class SectionedResultsChangesetWithToken<Collection, T> : Combine.Publisher where Collection : RealmSwift.RealmSectionedResult {
    public typealias Output = RealmSwift.SectionedResultsChange<Collection>
    public typealias Failure = Swift.Never
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.SectionedResultsChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.SectionedResultsChangesetWithToken<Collection, T> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverSectionedResultsChangeset<RealmSwift.RealmPublishers.SectionedResultsChangesetWithToken<Collection, T>, Collection, S> where S : Combine.Scheduler
    @objc deinit
  }
  @_hasMissingDesignatedInitializers public class SectionChangesetWithToken<Collection, T> : Combine.Publisher where Collection : RealmSwift.RealmSectionedResult {
    public typealias Output = RealmSwift.SectionedResultsChange<Collection>
    public typealias Failure = Swift.Never
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.SectionedResultsChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.SectionedResultsChangesetWithToken<Collection, T> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverSectionChangeset<RealmSwift.RealmPublishers.SectionChangesetWithToken<Collection, T>, Collection, S> where S : Combine.Scheduler
    @objc deinit
  }
  @_hasMissingDesignatedInitializers public class MapChangesetWithToken<Collection, T> : Combine.Publisher where Collection : RealmSwift.RealmKeyedCollection {
    public typealias Output = RealmSwift.RealmMapChange<Collection>
    public typealias Failure = Swift.Never
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RealmSwift.RealmMapChange<Collection>
    public func subscribe<S>(on scheduler: S) -> RealmSwift.RealmPublishers.MapChangesetWithToken<Collection, T> where S : Combine.Scheduler
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverKeyedCollectionChangeset<RealmSwift.RealmPublishers.MapChangesetWithToken<Collection, T>, Collection, S> where S : Combine.Scheduler
    @objc deinit
  }
  @frozen public struct MakeThreadSafeCollectionChangeset<Upstream, T> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmCollection, Upstream.Output == RealmSwift.RealmCollectionChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, S.Input == RealmSwift.RealmCollectionChange<T>
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverCollectionChangeset<Upstream, T, S> where S : Combine.Scheduler
  }
  @frozen public struct MakeThreadSafeKeyedCollectionChangeset<Upstream, T> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmKeyedCollection, Upstream.Output == RealmSwift.RealmMapChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, S.Input == RealmSwift.RealmMapChange<T>
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverKeyedCollectionChangeset<Upstream, T, S> where S : Combine.Scheduler
  }
  @frozen public struct MakeThreadSafeSectionedResultsChangeset<Upstream, T> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmSectionedResult, Upstream.Output == RealmSwift.SectionedResultsChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, Upstream.Failure == S.Failure, S.Input == RealmSwift.SectionedResultsChange<T>
    public func receive<S>(on scheduler: S) -> RealmSwift.RealmPublishers.DeferredHandoverSectionedResultsChangeset<Upstream, T, S> where S : Combine.Scheduler
  }
  @frozen public struct DeferredHandoverCollectionChangeset<Upstream, T, S> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmCollection, S : Combine.Scheduler, Upstream.Output == RealmSwift.RealmCollectionChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Sub.Input == RealmSwift.RealmCollectionChange<T>
  }
  @frozen public struct DeferredHandoverKeyedCollectionChangeset<Upstream, T, S> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmKeyedCollection, S : Combine.Scheduler, Upstream.Output == RealmSwift.RealmMapChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Sub.Input == RealmSwift.RealmMapChange<T>
  }
  @frozen public struct DeferredHandoverSectionedResultsChangeset<Upstream, T, S> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmSectionedResult, S : Combine.Scheduler, Upstream.Output == RealmSwift.SectionedResultsChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Sub.Input == RealmSwift.SectionedResultsChange<T>
  }
  @frozen public struct DeferredHandoverSectionChangeset<Upstream, T, S> : Combine.Publisher where Upstream : Combine.Publisher, T : RealmSwift.RealmSectionedResult, S : Combine.Scheduler, Upstream.Output == RealmSwift.SectionedResultsChange<T> {
    public typealias Failure = Upstream.Failure
    public typealias Output = Upstream.Output
    private let upstream: Upstream
    private let scheduler: S
    public func receive<Sub>(subscriber: Sub) where Sub : Combine.Subscriber, Upstream.Failure == Sub.Failure, Sub.Input == RealmSwift.SectionedResultsChange<T>
  }
}
extension RealmSwiftObject : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible {
  public typealias PersistedType = RealmSwift.Object
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self
  public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self?
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: RealmSwift.Object)
}
extension RealmSwiftEmbeddedObject : RealmSwift._PersistableInsideOptional, RealmSwift._DefaultConstructible {
  public typealias PersistedType = RealmSwift.EmbeddedObject
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self
  public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self?
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: RealmSwift.EmbeddedObject)
}
extension RealmSwift.List : RealmSwift._RealmSchemaDiscoverable where Element : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension RealmSwift.List : RealmSwift._HasPersistedType, RealmSwift._Persistable, RealmSwift._DefaultConstructible where Element : RealmSwift._Persistable {
  public typealias PersistedType = RealmSwift.List<Element>
  public static var _rlmRequiresCaching: Swift.Bool {
    get
  }
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: RealmSwift.List<Element>)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
extension RealmSwift.MutableSet : RealmSwift._RealmSchemaDiscoverable where Element : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension RealmSwift.MutableSet : RealmSwift._HasPersistedType, RealmSwift._Persistable, RealmSwift._DefaultConstructible where Element : RealmSwift._Persistable {
  public typealias PersistedType = RealmSwift.MutableSet<Element>
  public static var _rlmRequiresCaching: Swift.Bool {
    get
  }
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: RealmSwift.MutableSet<Element>)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
extension RealmSwift.Map : RealmSwift._RealmSchemaDiscoverable where Value : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension RealmSwift.Map : RealmSwift._HasPersistedType, RealmSwift._Persistable, RealmSwift._DefaultConstructible where Value : RealmSwift._Persistable {
  public typealias PersistedType = RealmSwift.Map<Key, Value>
  public static var _rlmRequiresCaching: Swift.Bool {
    get
  }
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Self
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: RealmSwift.Map<Key, Value>)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
extension RealmSwift.LinkingObjects {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
  public func _rlmPopulateProperty(_ prop: RLMProperty)
}
@available(*, deprecated)
extension RealmSwift.RealmOptional : RealmSwift._RealmSchemaDiscoverable where Value : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension RealmSwift.LinkingObjects : RealmSwift._HasPersistedType, RealmSwift._Persistable where Element : RealmSwift._Persistable {
  public typealias PersistedType = RealmSwift.LinkingObjects<Element>
  public static func _rlmDefaultValue() -> RealmSwift.LinkingObjects<Element>
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> RealmSwift.LinkingObjects<Element>
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: RealmSwift.LinkingObjects<Element>)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
extension Swift.Optional : RealmSwift._RealmSchemaDiscoverable where Wrapped : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension Swift.Optional : RealmSwift._HasPersistedType where Wrapped : RealmSwift._HasPersistedType {
  public typealias PersistedType = Wrapped.PersistedType?
}
extension Swift.Optional : RealmSwift._Persistable where Wrapped : RealmSwift._PersistableInsideOptional {
  public static func _rlmDefaultValue() -> Swift.Optional<Wrapped>
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16) -> Wrapped?
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: Swift.UInt16, _ value: Wrapped?)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
extension Swift.Optional : RealmSwift._PrimaryKey where Wrapped : RealmSwift._Persistable, Wrapped.PersistedType : RealmSwift._PrimaryKey {
}
extension Swift.Optional : RealmSwift._Indexable where Wrapped : RealmSwift._Persistable, Wrapped.PersistedType : RealmSwift._Indexable {
}
extension RealmSwift.RealmProperty : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension Swift.RawRepresentable where Self.RawValue : RealmSwift._RealmSchemaDiscoverable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public func _rlmPopulateProperty(_ prop: RLMProperty)
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension Swift.RawRepresentable where Self : RealmSwift._PersistableInsideOptional, Self.RawValue : RealmSwift._PersistableInsideOptional {
  public typealias PersistedType = Self.RawValue
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self
  public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self?
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Self)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
public protocol CustomPersistable : RealmSwift._CustomPersistable {
  init(persistedValue: Self.PersistedType)
  var persistableValue: Self.PersistedType { get }
}
public protocol FailableCustomPersistable : RealmSwift._CustomPersistable {
  init?(persistedValue: Self.PersistedType)
  var persistableValue: Self.PersistedType { get }
}
public protocol _CustomPersistable : RealmSwift._PersistableInsideOptional, RealmSwift._RealmCollectionValueInsideOptional {
}
extension RealmSwift._CustomPersistable {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public func _rlmPopulateProperty(_ prop: RLMProperty)
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension RealmSwift.CustomPersistable {
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self
  public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self?
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Self)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
  public static func _rlmDefaultValue() -> Self
  public func hash(into hasher: inout Swift.Hasher)
}
extension RealmSwift.FailableCustomPersistable {
  public static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self
  public static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self?
  public static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Self)
  public static func _rlmSetAccessor(_ prop: RLMProperty)
  public static func _rlmDefaultValue() -> Self
  public func hash(into hasher: inout Swift.Hasher)
}
extension RealmSwift.CustomPersistable {
  public static func _rlmFromObjc(_ value: Any, insideOptional: Swift.Bool) -> Self?
  public var _rlmObjcValue: Any {
    get
  }
}
extension RealmSwift.FailableCustomPersistable {
  public static func _rlmFromObjc(_ value: Any, insideOptional: Swift.Bool) -> Self?
  public var _rlmObjcValue: Any {
    get
  }
}
@_inheritsConvenienceInitializers @objc(RealmSwiftDecimal128) final public class Decimal128 : RLMDecimal128, Swift.Decodable, @unchecked Swift.Sendable {
  @objc override required dynamic public init()
  @objc override required dynamic public init(value: Any)
  @objc override required dynamic public init(number: Foundation.NSNumber)
  @objc override required dynamic public init(string: Swift.String) throws
  required public init(from decoder: any Swift.Decoder) throws
  public static var min: RealmSwift.Decimal128 {
    get
  }
  public static var max: RealmSwift.Decimal128 {
    get
  }
  @objc deinit
}
extension RealmSwift.Decimal128 : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RealmSwift.Decimal128 : Swift.ExpressibleByIntegerLiteral {
  convenience public init(integerLiteral value: Swift.Int64)
  public typealias IntegerLiteralType = Swift.Int64
}
extension RealmSwift.Decimal128 : Swift.ExpressibleByFloatLiteral {
  convenience public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension RealmSwift.Decimal128 : Swift.ExpressibleByStringLiteral {
  convenience public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension RealmSwift.Decimal128 : Swift.Comparable {
  public static func == (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func < (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func <= (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func >= (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
  public static func > (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> Swift.Bool
}
extension RealmSwift.Decimal128 : Swift.Numeric {
  convenience public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public typealias Magnitude = RealmSwift.Decimal128
  final public var magnitude: RealmSwift.Decimal128.Magnitude {
    get
  }
  public static func + (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  public static func - (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  public static func * (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  public static func *= (lhs: inout RealmSwift.Decimal128, rhs: RealmSwift.Decimal128)
  public static func / (lhs: RealmSwift.Decimal128, rhs: RealmSwift.Decimal128) -> RealmSwift.Decimal128
}
extension RealmSwift.Decimal128 {
  public typealias Stride = RealmSwift.Decimal128
  final public func distance(to other: RealmSwift.Decimal128) -> RealmSwift.Decimal128
  final public func advanced(by n: RealmSwift.Decimal128) -> RealmSwift.Decimal128
}
extension RealmSwift.Decimal128 {
  final public var isSignaling: Swift.Bool {
    get
  }
  final public var isSignalingNaN: Swift.Bool {
    get
  }
}
public typealias EmbeddedObject = RealmSwiftEmbeddedObject
extension RealmSwiftEmbeddedObject : RealmSwift._RealmCollectionValueInsideOptional {
  @objc override public static func isEmbedded() -> Swift.Bool
  convenience public init(value: Any)
  public var realm: RealmSwift.Realm? {
    get
  }
  public var objectSchema: RealmSwift.ObjectSchema {
    get
  }
  @objc override final public var isInvalidated: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc override public static func _getProperties() -> [RLMProperty]
  @objc dynamic open class func ignoredProperties() -> [Swift.String]
  @objc override dynamic open class func propertiesMapping() -> [Swift.String : Swift.String]
  @available(*, unavailable, renamed: "propertiesMapping", message: "`_realmColumnNames` private API is unavailable in our Swift SDK, please use the override `.propertiesMapping()` instead.")
  @objc override dynamic open class func _realmColumnNames() -> [Swift.String : Swift.String]
  @objc dynamic open subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set
  }
  public func observe<T>(on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<T>) -> Swift.Void) -> RealmSwift.NotificationToken where T : RLMObjectBase
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A, T>(keyPaths: [Swift.String]? = nil, on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.ObjectChange<T>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor, T : RealmSwiftObject
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A, T>(keyPaths: [Swift.PartialKeyPath<T>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.ObjectChange<T>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor, T : RealmSwiftObject
  public func dynamicList(_ propertyName: Swift.String) -> RealmSwift.List<RealmSwift.DynamicObject>
  public func isSameObject(as object: RealmSwift.EmbeddedObject?) -> Swift.Bool
}
extension RealmSwiftEmbeddedObject : RealmSwift.ThreadConfined {
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> Self
  public func thaw() -> Self?
}
extension RealmSwift.Realm {
  public typealias Error = RLMError
}
extension RLMError {
  public static let callFailed: RealmSwift.Realm.Error
  public var fileURL: Foundation.URL? {
    get
  }
}
extension RLMError : @retroactive Swift.Equatable {
}
public func == (lhs: any Swift.Error, rhs: any Swift.Error) -> Swift.Bool
public struct Events {
  public func beginScope(activity: Swift.String) -> RealmSwift.Events.Scope
  @available(*, unavailable, message: "Use EventScope.commit()")
  public func endScope(completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  public func recordEvent(activity: Swift.String, eventType: Swift.String? = nil, data: Swift.String? = nil, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  public func updateMetadata(_ newMetadata: [Swift.String : Swift.String])
  @_hasMissingDesignatedInitializers public class Scope {
    public func commit(completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
    public func cancel()
    public var isActive: Swift.Bool {
      get
    }
    @objc deinit
  }
}
@available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, macCatalyst 13.0, *)
extension RealmSwift.Events.Scope {
  @_disfavoredOverload public func commit() -> Combine.Future<Swift.Void, any Swift.Error>
}
@available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, macCatalyst 13.0, *)
extension RealmSwift.Events {
  @available(*, unavailable, message: "Use EventScope.commit()")
  public func endScope() -> Combine.Future<Swift.Void, any Swift.Error>
  @_disfavoredOverload public func recordEvent(activity: Swift.String, eventType: Swift.String? = nil, data: Swift.String? = nil) -> Combine.Future<Swift.Void, any Swift.Error>
}
extension RealmSwift.Realm {
  public var events: RealmSwift.Events? {
    get
  }
}
@frozen public struct EventConfiguration : Swift.Sendable {
  public var metadata: [Swift.String : Swift.String]?
  public var syncUser: RealmSwift.User?
  public var partitionPrefix: Swift.String = "events"
  public typealias LoggerFunction = @Sendable (RealmSwift.SyncLogLevel, Swift.String) -> Swift.Void
  @preconcurrency public var logger: RealmSwift.EventConfiguration.LoggerFunction?
  @preconcurrency public var errorHandler: (@Sendable (any Swift.Error) -> Swift.Void)?
  @preconcurrency public init(metadata: [Swift.String : Swift.String]? = nil, syncUser: RealmSwift.User? = nil, partitionPrefix: Swift.String = "events", logger: RealmSwift.EventConfiguration.LoggerFunction? = nil, errorHandler: (@Sendable (any Swift.Error) -> Swift.Void)? = nil)
}
@objc(RLMCustomEventRepresentable) public protocol CustomEventRepresentable {
  @objc func customEventRepresentation() -> Swift.String
}
public typealias GeoPoint = RLMGeospatialPoint
public typealias GeoBox = RLMGeospatialBox
extension RLMGeospatialBox {
  convenience public init?(bottomLeft: (Swift.Double, Swift.Double), topRight: (Swift.Double, Swift.Double))
}
public typealias GeoPolygon = RLMGeospatialPolygon
extension RLMGeospatialPolygon {
  convenience public init?(outerRing: [(Swift.Double, Swift.Double)], holes: [[(Swift.Double, Swift.Double)]] = [])
  convenience public init?(outerRing: [(Swift.Double, Swift.Double)], holes: [(Swift.Double, Swift.Double)]...)
}
public typealias Distance = RLMDistance
public typealias GeoCircle = RLMGeospatialCircle
extension RLMGeospatialCircle {
  convenience public init?(center: (Swift.Double, Swift.Double), radiusInRadians: Swift.Double)
  convenience public init?(center: (Swift.Double, Swift.Double), radius: RealmSwift.Distance)
}
public func _name<T>(for keyPath: Swift.PartialKeyPath<T>) -> Swift.String where T : RLMObjectBase
public func _name<O, T>(for keyPath: Swift.PartialKeyPath<T>) -> Swift.String where O : RLMObjectBase, O : RealmSwift.RealmCollectionValue, O : RealmSwift.ThreadConfined, T : RealmSwift.Projection<O>
@frozen public struct LinkingObjects<Element> where Element : RLMObjectBase, Element : RealmSwift.RealmCollectionValue {
  public init(fromType _: Element.Type, property propertyName: Swift.String)
  public var description: Swift.String {
    get
  }
  public subscript(index: Swift.Int) -> Element {
    get
  }
  public static func == (lhs: RealmSwift.LinkingObjects<Element>, rhs: RealmSwift.LinkingObjects<Element>) -> Swift.Bool
  internal var propertyName: Swift.String
  internal var handle: RLMLinkingObjectsHandle?
  internal var lastAccessedNames: Foundation.NSMutableArray?
  public func makeIterator() -> RealmSwift.RLMIterator<Element>
  public typealias Elements = RealmSwift.LinkingObjects<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.LinkingObjects<Element>>
}
@_inheritsConvenienceInitializers final public class List<Element> : RLMSwiftCollectionBase where Element : RealmSwift.RealmCollectionValue {
  @objc override dynamic public init()
  @objc override dynamic public init(collection: any RLMCollection)
  final public subscript(position: Swift.Int) -> Element {
    get
    set
  }
  @nonobjc final public func value(forKey key: Swift.String) -> [Swift.AnyObject]
  @nonobjc final public func value(forKeyPath keyPath: Swift.String) -> [Swift.AnyObject]
  final public func append(_ object: Element)
  final public func append<S>(objectsIn objects: S) where Element == S.Element, S : Swift.Sequence
  final public func insert(_ object: Element, at index: Swift.Int)
  final public func remove(at index: Swift.Int)
  final public func removeAll()
  final public func replace(index: Swift.Int, object: Element)
  final public func move(from: Swift.Int, to: Swift.Int)
  final public func swapAt(_ index1: Swift.Int, _ index2: Swift.Int)
  @objc override public static func _backingCollectionType() -> Swift.AnyClass
  @objc override final public var description: Swift.String {
    @objc get
  }
  public typealias Elements = RealmSwift.List<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  @objc deinit
}
extension RealmSwift.List {
  final public func replaceSubrange<C, R>(_ subrange: R, with newElements: C) where Element == C.Element, C : Swift.Collection, R : Swift.RangeExpression, R.Bound == Swift.Int
}
extension RealmSwift.List : Swift.MutableCollection {
  public typealias SubSequence = Swift.Slice<RealmSwift.List<Element>>
  final public subscript(bounds: Swift.Range<Swift.Int>) -> RealmSwift.List<Element>.SubSequence {
    get
    set
  }
  final public func removeFirst(_ number: Swift.Int = 1)
  final public func removeLast(_ number: Swift.Int = 1)
  final public func insert<C>(contentsOf newElements: C, at i: Swift.Int) where Element == C.Element, C : Swift.Collection
  final public func removeSubrange<R>(_ boundsExpression: R) where R : Swift.RangeExpression, R.Bound == Swift.Int
  final public func remove(atOffsets offsets: Foundation.IndexSet)
  final public func move(fromOffsets offsets: Foundation.IndexSet, toOffset destination: Swift.Int)
  final public func makeIterator() -> RealmSwift.RLMIterator<Element>
}
extension RealmSwift.List : Swift.Decodable where Element : Swift.Decodable {
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension RealmSwift.List : Swift.Encodable where Element : Swift.Encodable {
}
public protocol _MapKey : RealmSwift._ObjcBridgeable, Swift.Hashable {
  static var _rlmType: RLMPropertyType { get }
}
extension Swift.String : RealmSwift._MapKey {
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Map<Key, Value> : RLMSwiftCollectionBase where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue {
  final public var realm: RealmSwift.Realm? {
    get
  }
  final public var isInvalidated: Swift.Bool {
    get
  }
  final public var keys: [Key] {
    get
  }
  final public var values: [Value] {
    get
  }
  @objc override dynamic public init()
  @objc override dynamic public init(collection: any RLMCollection)
  @objc final public var count: Swift.Int {
    @objc get
  }
  final public func updateValue(_ value: Value, forKey key: Key)
  final public func merge<S>(_ sequence: S, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows where S : Swift.Sequence, S.Element == (key: Key, value: Value)
  final public func merge(_ other: RealmSwift.Map<Key, Value>, uniquingKeysWith combine: (Value, Value) throws -> Value) rethrows
  final public func removeObject(for key: Key)
  final public func removeAll()
  final public subscript(key: Key) -> Value? {
    get
    set
  }
  @objc final public func object(forKey key: Swift.AnyObject) -> Swift.AnyObject?
  @nonobjc final public func value(forKey key: Swift.String) -> Swift.AnyObject?
  @nonobjc final public func value(forKeyPath keyPath: Swift.String) -> Swift.AnyObject?
  final public func setValue(_ value: Any?, forKey key: Swift.String)
  final public func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Value>
  final public func `where`(_ isIncluded: (RealmSwift.Query<Value>) -> RealmSwift.Query<Swift.Bool>) -> RealmSwift.Results<Value>
  final public func contains(where predicate: @escaping (_ key: Key, _ value: Value) -> Swift.Bool) -> Swift.Bool
  final public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Value>
  final public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Value>
  final public func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Value> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  final public func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  final public func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  final public func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  final public func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  final public func observe(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmMapChange<RealmSwift.Map<Key, Value>>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  final public func observe<A>(keyPaths: [Swift.String]? = nil, on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.RealmMapChange<RealmSwift.Map<Key, Value>>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  final public func observe<A>(keyPaths: [Swift.PartialKeyPath<Value.Wrapped>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.RealmMapChange<RealmSwift.Map<Key, Value>>) -> Swift.Void) async -> RealmSwift.NotificationToken where Value : RealmSwift.OptionalProtocol, A : _Concurrency.Actor, Value.Wrapped : RLMObjectBase
  final public var isFrozen: Swift.Bool {
    get
  }
  final public func freeze() -> RealmSwift.Map<Key, Value>
  final public func thaw() -> RealmSwift.Map<Key, Value>?
  @objc override public static func _backingCollectionType() -> Swift.AnyClass
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension RealmSwift.Map : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension RealmSwift.Map : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RealmSwift.Map : Swift.Sequence {
  final public func makeIterator() -> RealmSwift.RLMMapIterator<RealmSwift.SingleMapEntry<Key, Value>>
  public typealias Element = RealmSwift.SingleMapEntry<Key, Value>
  public typealias Iterator = RealmSwift.RLMMapIterator<RealmSwift.SingleMapEntry<Key, Value>>
}
extension RealmSwift.Map {
  public struct KeyValueSequence : Swift.Sequence {
    public func makeIterator() -> RealmSwift.RLMKeyValueIterator<Key, Value>
    public typealias Element = RealmSwift.RLMKeyValueIterator<Key, Value>.Element
    public typealias Iterator = RealmSwift.RLMKeyValueIterator<Key, Value>
  }
  final public func asKeyValueSequence() -> RealmSwift.Map<Key, Value>.KeyValueSequence
}
@frozen public enum RealmMapChange<Collection> where Collection : RealmSwift.RealmKeyedCollection {
  case initial(Collection)
  case update(Collection, deletions: [Collection.Key], insertions: [Collection.Key], modifications: [Collection.Key])
  case error(any Swift.Error)
}
extension RealmSwift.Map : RealmSwift.RealmKeyedCollection {
}
public struct MapIndex {
  public var offset: Swift.UInt
}
public struct SingleMapEntry<Key, Value> : RealmSwift._RealmMapValue, Swift.Hashable where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue {
  public static func == (lhs: RealmSwift.SingleMapEntry<Key, Value>, rhs: RealmSwift.SingleMapEntry<Key, Value>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var key: RealmSwift.SingleMapEntry<Key, Value>.Key
  public var value: RealmSwift.SingleMapEntry<Key, Value>.Value
  public var hashValue: Swift.Int {
    get
  }
}
public typealias MigrationBlock = @Sendable (_ migration: RealmSwift.Migration, _ oldSchemaVersion: Swift.UInt64) -> Swift.Void
public typealias MigrationObject = RealmSwift.DynamicObject
public typealias MigrationObjectEnumerateBlock = (_ oldObject: RealmSwift.MigrationObject?, _ newObject: RealmSwift.MigrationObject?) -> Swift.Void
public func schemaVersionAtURL(_ fileURL: Foundation.URL, encryptionKey: Foundation.Data? = nil) throws -> Swift.UInt64
extension RealmSwift.Realm {
  public static func performMigration(for configuration: RealmSwift.Realm.Configuration = Configuration.defaultConfiguration) throws
}
public typealias Migration = RLMMigration
extension RLMMigration {
  public var oldSchema: RealmSwift.Schema {
    get
  }
  public var newSchema: RealmSwift.Schema {
    get
  }
  public func enumerateObjects(ofType typeName: Swift.String, _ block: (_ oldObject: RealmSwift.MigrationObject?, _ newObject: RealmSwift.MigrationObject?) -> Swift.Void)
  @discardableResult
  public func create(_ typeName: Swift.String, value: Any = [Any]()) -> RealmSwift.MigrationObject
  public func delete(_ object: RealmSwift.MigrationObject)
  @discardableResult
  public func deleteData(forType typeName: Swift.String) -> Swift.Bool
  public func renameProperty(onType typeName: Swift.String, from oldName: Swift.String, to newName: Swift.String)
}
public typealias MongoClient = RLMMongoClient
public typealias MongoDatabase = RLMMongoDatabase
public typealias FindOptions = RLMFindOptions
extension RLMFindOptions {
  public var projection: RealmSwift.Document? {
    get
    set
  }
  @available(*, deprecated, message: "Use `sorting`")
  public var sort: RealmSwift.Document? {
    get
    set
  }
  public var sorting: [RealmSwift.Document] {
    get
    set
  }
  @available(*, deprecated, message: "Use init(limit:projection:sorting:)")
  convenience public init(_ limit: Swift.Int?, _ projection: RealmSwift.Document?, _ sort: RealmSwift.Document?)
  convenience public init(_ limit: Swift.Int = 0, _ projection: RealmSwift.Document? = nil, _ sorting: [RealmSwift.Document] = [])
  @available(*, deprecated, message: "Use init(limit:projection:sorting:)")
  convenience public init(limit: Swift.Int?, projection: RealmSwift.Document?, sort: RealmSwift.Document?)
}
public typealias FindOneAndModifyOptions = RLMFindOneAndModifyOptions
extension RLMFindOneAndModifyOptions {
  public var projection: RealmSwift.Document? {
    get
    set
  }
  @available(*, deprecated, message: "Use `sorting`")
  public var sort: RealmSwift.Document? {
    get
    set
  }
  public var sorting: [RealmSwift.Document] {
    get
    set
  }
  @available(*, deprecated, message: "Use init(projection:sorting:upsert:shouldReturnNewDocument:)")
  convenience public init(_ projection: RealmSwift.Document?, _ sort: RealmSwift.Document?, _ upsert: Swift.Bool = false, _ shouldReturnNewDocument: Swift.Bool = false)
  convenience public init(_ projection: RealmSwift.Document?, _ sorting: [RealmSwift.Document] = [], _ upsert: Swift.Bool = false, _ shouldReturnNewDocument: Swift.Bool = false)
  @available(*, deprecated, message: "Use init(projection:sorting:upsert:shouldReturnNewDocument:)")
  convenience public init(projection: RealmSwift.Document?, sort: RealmSwift.Document?, upsert: Swift.Bool = false, shouldReturnNewDocument: Swift.Bool = false)
}
public typealias UpdateResult = RLMUpdateResult
public typealias MongoInsertBlock = @Sendable (Swift.Result<RealmSwift.AnyBSON, any Swift.Error>) -> Swift.Void
public typealias MongoInsertManyBlock = @Sendable (Swift.Result<[RealmSwift.AnyBSON], any Swift.Error>) -> Swift.Void
public typealias MongoFindBlock = @Sendable (Swift.Result<[RealmSwift.Document], any Swift.Error>) -> Swift.Void
public typealias MongoFindOneBlock = @Sendable (Swift.Result<RealmSwift.Document?, any Swift.Error>) -> Swift.Void
public typealias MongoCountBlock = @Sendable (Swift.Result<Swift.Int, any Swift.Error>) -> Swift.Void
public typealias MongoUpdateBlock = @Sendable (Swift.Result<RealmSwift.UpdateResult, any Swift.Error>) -> Swift.Void
public typealias MongoCollection = RLMMongoCollection
public typealias ChangeStream = RLMChangeStream
public protocol ChangeEventDelegate : AnyObject {
  func changeStreamDidOpen(_ changeStream: RealmSwift.ChangeStream)
  func changeStreamDidClose(with error: (any Swift.Error)?)
  func changeStreamDidReceive(error: any Swift.Error)
  func changeStreamDidReceive(changeEvent: RealmSwift.AnyBSON?)
}
extension RLMMongoCollection {
  public func watch(delegate: any RealmSwift.ChangeEventDelegate, queue: Dispatch.DispatchQueue = .main) -> RealmSwift.ChangeStream
  public func watch(matchFilter: RealmSwift.Document, delegate: any RealmSwift.ChangeEventDelegate, queue: Dispatch.DispatchQueue = .main) -> RealmSwift.ChangeStream
  public func watch(filterIds: [RealmSwift.ObjectId], delegate: any RealmSwift.ChangeEventDelegate, queue: Dispatch.DispatchQueue = .main) -> RealmSwift.ChangeStream
}
extension RLMMongoCollection {
  @preconcurrency public func insertOne(_ document: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoInsertBlock)
  @preconcurrency public func insertMany(_ documents: [RealmSwift.Document], _ completion: @escaping RealmSwift.MongoInsertManyBlock)
  @preconcurrency public func find(filter: RealmSwift.Document, options: RealmSwift.FindOptions = FindOptions(), _ completion: @escaping RealmSwift.MongoFindBlock)
  @preconcurrency public func findOneDocument(filter: RealmSwift.Document, options: RealmSwift.FindOptions = FindOptions(), _ completion: @escaping RealmSwift.MongoFindOneBlock)
  @preconcurrency public func aggregate(pipeline: [RealmSwift.Document], _ completion: @escaping RealmSwift.MongoFindBlock)
  @preconcurrency public func count(filter: RealmSwift.Document, limit: Swift.Int? = nil, _ completion: @escaping RealmSwift.MongoCountBlock)
  @preconcurrency public func deleteOneDocument(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoCountBlock)
  @preconcurrency public func deleteManyDocuments(filter: RealmSwift.Document, _ completion: @escaping RealmSwift.MongoCountBlock)
  @preconcurrency public func updateOneDocument(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool = false, _ completion: @escaping RealmSwift.MongoUpdateBlock)
  @preconcurrency public func updateManyDocuments(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool = false, _ completion: @escaping RealmSwift.MongoUpdateBlock)
  @preconcurrency public func findOneAndUpdate(filter: RealmSwift.Document, update: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions = .init(), _ completion: @escaping RealmSwift.MongoFindOneBlock)
  @preconcurrency public func findOneAndReplace(filter: RealmSwift.Document, replacement: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions = .init(), _ completion: @escaping RealmSwift.MongoFindOneBlock)
  @preconcurrency public func findOneAndDelete(filter: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions = .init(), _ completion: @escaping RealmSwift.MongoFindOneBlock)
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMMongoCollection {
  public func insertOne(_ document: RealmSwift.Document) async throws -> RealmSwift.AnyBSON
  public func insertMany(_ documents: [RealmSwift.Document]) async throws -> [RealmSwift.AnyBSON]
  public func find(filter: RealmSwift.Document, options: RealmSwift.FindOptions = .init(), _isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> [RealmSwift.Document]
  public func findOneDocument(filter: RealmSwift.Document, options: RealmSwift.FindOptions = .init(), _isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> RealmSwift.Document?
  public func aggregate(pipeline: [RealmSwift.Document]) async throws -> [RealmSwift.Document]
  public func count(filter: RealmSwift.Document, limit: Swift.Int? = nil) async throws -> Swift.Int
  public func deleteOneDocument(filter: RealmSwift.Document) async throws -> Swift.Int
  public func deleteManyDocuments(filter: RealmSwift.Document) async throws -> Swift.Int
  public func updateOneDocument(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool? = nil) async throws -> RealmSwift.UpdateResult
  public func updateManyDocuments(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool? = nil) async throws -> RealmSwift.UpdateResult
  public func findOneAndUpdate(filter: RealmSwift.Document, update: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions = .init(), _isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> RealmSwift.Document?
  public func findOneAndReplace(filter: RealmSwift.Document, replacement: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions = .init(), _isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> RealmSwift.Document?
  public func findOneAndDelete(filter: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions = .init(), _isolation: isolated (any _Concurrency.Actor)? = #isolation) async throws -> RealmSwift.Document?
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.Publishers {
  public struct WatchPublisher : Combine.Publisher {
    public typealias Output = RealmSwift.AnyBSON
    public typealias Failure = Swift.Error
    public func onOpen(_ event: @escaping @Sendable () -> Swift.Void) -> Combine.Publishers.WatchPublisher
    public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == any Swift.Error, S.Input == RealmSwift.AnyBSON
    public func subscribe<S>(on scheduler: S) -> Combine.Publishers.WatchPublisher where S : Combine.Scheduler
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMMongoCollection {
  public func watch() -> Combine.Publishers.WatchPublisher
  public func watch(filterIds: [RealmSwift.ObjectId]) -> Combine.Publishers.WatchPublisher
  public func watch(matchFilter: RealmSwift.Document) -> Combine.Publishers.WatchPublisher
}
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension RLMMongoCollection {
  public var changeEvents: Combine.AsyncThrowingPublisher<Combine.Publishers.WatchPublisher> {
    get
  }
  public func changeEvents(onOpen: @escaping @Sendable () -> Swift.Void) -> Combine.AsyncThrowingPublisher<Combine.Publishers.WatchPublisher>
  public func changeEvents(filterIds: [RealmSwift.ObjectId], onOpen: (@Sendable () -> Swift.Void)? = nil) -> Combine.AsyncThrowingPublisher<Combine.Publishers.WatchPublisher>
  public func changeEvents(matchFilter: RealmSwift.Document, onOpen: (@Sendable () -> Swift.Void)? = nil) -> Combine.AsyncThrowingPublisher<Combine.Publishers.WatchPublisher>
}
@available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, macCatalyst 13.0, *)
@usableFromInline
internal func future<T>(_ fn: @escaping (@escaping @Sendable (Swift.Result<T, any Swift.Error>) -> Swift.Void) -> Swift.Void) -> Combine.Future<T, any Swift.Error>
@available(macOS 10.15, watchOS 6.0, iOS 13.0, tvOS 13.0, macCatalyst 13.0, *)
extension RLMMongoCollection {
  public func insertOne(_ document: RealmSwift.Document) -> Combine.Future<RealmSwift.AnyBSON, any Swift.Error>
  public func insertMany(_ documents: [RealmSwift.Document]) -> Combine.Future<[RealmSwift.AnyBSON], any Swift.Error>
  public func find(filter: RealmSwift.Document, options: RealmSwift.FindOptions) -> Combine.Future<[RealmSwift.Document], any Swift.Error>
  public func find(filter: RealmSwift.Document) -> Combine.Future<[RealmSwift.Document], any Swift.Error>
  public func findOneDocument(filter: RealmSwift.Document, options: RealmSwift.FindOptions) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func findOneDocument(filter: RealmSwift.Document) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func aggregate(pipeline: [RealmSwift.Document]) -> Combine.Future<[RealmSwift.Document], any Swift.Error>
  public func count(filter: RealmSwift.Document, limit: Swift.Int) -> Combine.Future<Swift.Int, any Swift.Error>
  public func count(filter: RealmSwift.Document) -> Combine.Future<Swift.Int, any Swift.Error>
  public func deleteOneDocument(filter: RealmSwift.Document) -> Combine.Future<Swift.Int, any Swift.Error>
  public func deleteManyDocuments(filter: RealmSwift.Document) -> Combine.Future<Swift.Int, any Swift.Error>
  public func updateOneDocument(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool) -> Combine.Future<RealmSwift.UpdateResult, any Swift.Error>
  public func updateOneDocument(filter: RealmSwift.Document, update: RealmSwift.Document) -> Combine.Future<RealmSwift.UpdateResult, any Swift.Error>
  public func updateManyDocuments(filter: RealmSwift.Document, update: RealmSwift.Document, upsert: Swift.Bool) -> Combine.Future<RealmSwift.UpdateResult, any Swift.Error>
  public func updateManyDocuments(filter: RealmSwift.Document, update: RealmSwift.Document) -> Combine.Future<RealmSwift.UpdateResult, any Swift.Error>
  public func findOneAndUpdate(filter: RealmSwift.Document, update: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func findOneAndUpdate(filter: RealmSwift.Document, update: RealmSwift.Document) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func findOneAndReplace(filter: RealmSwift.Document, replacement: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func findOneAndReplace(filter: RealmSwift.Document, replacement: RealmSwift.Document) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func findOneAndDelete(filter: RealmSwift.Document, options: RealmSwift.FindOneAndModifyOptions) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
  public func findOneAndDelete(filter: RealmSwift.Document) -> Combine.Future<RealmSwift.Document?, any Swift.Error>
}
@_inheritsConvenienceInitializers final public class MutableSet<Element> : RLMSwiftCollectionBase where Element : RealmSwift.RealmCollectionValue {
  @objc override dynamic public init()
  @objc override dynamic public init(collection: any RLMCollection)
  @nonobjc final public func value(forKey key: Swift.String) -> [Swift.AnyObject]
  final public subscript(position: Swift.Int) -> Element {
    get
  }
  final public func contains(_ object: Element) -> Swift.Bool
  final public func isSubset(of possibleSuperset: RealmSwift.MutableSet<Element>) -> Swift.Bool
  final public func intersects(_ otherSet: RealmSwift.MutableSet<Element>) -> Swift.Bool
  final public func insert(_ object: Element)
  final public func insert<S>(objectsIn objects: S) where Element == S.Element, S : Swift.Sequence
  final public func remove(_ object: Element)
  final public func removeAll()
  final public func formIntersection(_ other: RealmSwift.MutableSet<Element>)
  final public func subtract(_ other: RealmSwift.MutableSet<Element>)
  final public func formUnion(_ other: RealmSwift.MutableSet<Element>)
  @objc override public static func _backingCollectionType() -> Swift.AnyClass
  @objc override final public var description: Swift.String {
    @objc get
  }
  final public func makeIterator() -> RealmSwift.RLMIterator<Element>
  final public func index(of object: Element) -> Swift.Int?
  final public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  final public func index(matching isIncluded: (RealmSwift.Query<Element>) -> RealmSwift.Query<Swift.Bool>) -> Swift.Int?
  public typealias Elements = RealmSwift.MutableSet<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.MutableSet<Element>>
  @objc deinit
}
extension RealmSwift.MutableSet : Swift.Decodable where Element : Swift.Decodable {
  convenience public init(from decoder: any Swift.Decoder) throws
}
extension RealmSwift.MutableSet : Swift.Encodable where Element : Swift.Encodable {
}
public protocol _ObjcBridgeable {
  static func _rlmFromObjc(_ value: Any, insideOptional: Swift.Bool) -> Self?
  var _rlmObjcValue: Any { get }
}
extension RLMObjectBase {
  public class func _rlmFromObjc(_ value: Any) -> Self?
  public var _rlmObjcValue: Any {
    get
  }
}
extension Swift.Float {
  public static func _rlmFromObjc(_ value: Any) -> Swift.Float?
  public var _rlmObjcValue: Any {
    get
  }
}
extension Swift.Int8 {
  public static func _rlmFromObjc(_ value: Any) -> Swift.Int8?
  public var _rlmObjcValue: Any {
    get
  }
}
extension Swift.Int16 {
  public static func _rlmFromObjc(_ value: Any) -> Swift.Int16?
  public var _rlmObjcValue: Any {
    get
  }
}
extension Swift.Int32 {
  public static func _rlmFromObjc(_ value: Any) -> Swift.Int32?
  public var _rlmObjcValue: Any {
    get
  }
}
extension Swift.Int64 {
  public static func _rlmFromObjc(_ value: Any) -> Swift.Int64?
  public var _rlmObjcValue: Any {
    get
  }
}
extension Swift.Optional : RealmSwift._ObjcBridgeable where Wrapped : RealmSwift._ObjcBridgeable {
  public static func _rlmFromObjc(_ value: Any) -> Swift.Optional<Wrapped>?
  public var _rlmObjcValue: Any {
    get
  }
}
extension RealmSwift.Decimal128 {
  public static func _rlmFromObjc(_ value: Any) -> RealmSwift.Decimal128?
  final public var _rlmObjcValue: Any {
    get
  }
}
extension RealmSwift.AnyRealmValue {
  public static func _rlmFromObjc(_ value: Any) -> RealmSwift.AnyRealmValue?
  public var _rlmObjcValue: Any {
    get
  }
}
extension RealmSwift.Map {
  final public var _rlmObjcValue: Any {
    get
  }
  public static func _rlmFromObjc(_ value: Any) -> Self?
}
extension RealmSwift.LinkingObjects : RealmSwift._ObjcBridgeable {
}
extension RealmSwift.Results : RealmSwift._ObjcBridgeable {
}
extension RealmSwift.AnyRealmCollection : RealmSwift._ObjcBridgeable {
}
extension RealmSwift.List : RealmSwift._ObjcBridgeable {
}
extension RealmSwift.MutableSet : RealmSwift._ObjcBridgeable {
}
extension RealmSwift.SectionedResults {
  public static func _rlmFromObjc(_ value: Any, insideOptional: Swift.Bool) -> RealmSwift.SectionedResults<Key, SectionElement>?
  public var _rlmObjcValue: Any {
    get
  }
}
extension RealmSwift.ResultsSection {
  public static func _rlmFromObjc(_ value: Any, insideOptional: Swift.Bool) -> RealmSwift.ResultsSection<Key, T>?
  public var _rlmObjcValue: Any {
    get
  }
}
extension RLMSwiftCollectionBase {
  public static func == (lhs: RLMSwiftCollectionBase, rhs: RLMSwiftCollectionBase) -> Swift.Bool
}
extension RLMSwiftCollectionBase : @retroactive Swift.Equatable {
}
extension RealmSwift.Projection {
  public static func _rlmFromObjc(_ value: Any) -> Self?
  public var _rlmObjcValue: Any {
    get
  }
}
public protocol _PossiblyAggregateable : RealmSwift._ObjcBridgeable {
  associatedtype PersistedType
}
extension Foundation.NSDate : RealmSwift._PossiblyAggregateable {
}
extension Foundation.NSNumber : RealmSwift._PossiblyAggregateable {
}
public typealias Object = RealmSwiftObject
extension RealmSwiftObject : RealmSwift._RealmCollectionValueInsideOptional {
  convenience public init(value: Any)
  public var realm: RealmSwift.Realm? {
    get
  }
  public var objectSchema: RealmSwift.ObjectSchema {
    get
  }
  @objc dynamic override open var isInvalidated: Swift.Bool {
    @objc get
  }
  @objc override dynamic open var description: Swift.String {
    @objc get
  }
  @objc override public static func _getProperties() -> [RLMProperty]
  @objc dynamic open class func primaryKey() -> Swift.String?
  @objc dynamic open class func ignoredProperties() -> [Swift.String]
  @objc dynamic open class func indexedProperties() -> [Swift.String]
  @objc override dynamic open class func propertiesMapping() -> [Swift.String : Swift.String]
  @available(*, unavailable, renamed: "propertiesMapping", message: "`_realmColumnNames` private API is unavailable in our Swift SDK, please use the override `.propertiesMapping()` instead.")
  @objc override dynamic open class func _realmColumnNames() -> [Swift.String : Swift.String]
  @objc dynamic open subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set
  }
  public func observe<T>(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<T>) -> Swift.Void) -> RealmSwift.NotificationToken where T : RLMObjectBase
  public func observe<T>(keyPaths: [Swift.PartialKeyPath<T>], on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<T>) -> Swift.Void) -> RealmSwift.NotificationToken where T : RLMObjectBase
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A, T>(keyPaths: [Swift.String]? = nil, on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.ObjectChange<T>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor, T : RealmSwiftObject
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A, T>(keyPaths: [Swift.PartialKeyPath<T>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.ObjectChange<T>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor, T : RealmSwiftObject
  public func dynamicList(_ propertyName: Swift.String) -> RealmSwift.List<RealmSwift.DynamicObject>
  public func dynamicMutableSet(_ propertyName: Swift.String) -> RealmSwift.MutableSet<RealmSwift.DynamicObject>
  public func dynamicMap<Key>(_ propertyName: Swift.String) -> RealmSwift.Map<Key, RealmSwift.DynamicObject?> where Key : RealmSwift._MapKey
  public func isSameObject(as object: RealmSwift.Object?) -> Swift.Bool
}
extension RealmSwiftObject : RealmSwift.ThreadConfined {
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> Self
  public func thaw() -> Self?
}
@frozen public struct PropertyChange {
  public let name: Swift.String
  public let oldValue: Any?
  public let newValue: Any?
}
@frozen public enum ObjectChange<T> {
  case error(_: Foundation.NSError)
  case change(T, [RealmSwift.PropertyChange])
  case deleted
}
@_inheritsConvenienceInitializers @objc(RealmSwiftDynamicObject) @dynamicMemberLookup final public class DynamicObject : RealmSwift.Object {
  @objc override final public subscript(key: Swift.String) -> Any? {
    @objc get
    @objc set(value)
  }
  final public subscript(dynamicMember member: Swift.String) -> Any? {
    get
    set(value)
  }
  @objc override final public func value(forUndefinedKey key: Swift.String) -> Any?
  @objc override final public func setValue(_ value: Any?, forUndefinedKey key: Swift.String)
  @objc override public static func shouldIncludeInDefaultSchema() -> Swift.Bool
  @objc override public static func sharedSchema() -> RLMObjectSchema?
  @objc override dynamic public init()
  @objc deinit
}
public protocol RealmEnum : RealmSwift.RealmOptionalType, RealmSwift._RealmSchemaDiscoverable {
}
extension RealmSwift.RealmEnum where Self : Swift.RawRepresentable, Self.RawValue : RealmSwift._ObjcBridgeable, Self.RawValue : RealmSwift._RealmSchemaDiscoverable {
  public var _rlmObjcValue: Any {
    get
  }
  public static func _rlmFromObjc(_ value: Any, insideOptional: Swift.Bool) -> Self?
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
}
@objc(RealmSwiftObjectId) final public class ObjectId : RLMObjectId, Swift.Decodable, @unchecked Swift.Sendable {
  @objc override required dynamic public init()
  @objc override public static func generate() -> RealmSwift.ObjectId
  @objc override required dynamic public init(string: Swift.String) throws
  required public init(timestamp: Foundation.Date, machineId: Swift.Int, processId: Swift.Int)
  required public init(_ str: Swift.StaticString)
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
}
extension RealmSwift.ObjectId : Swift.Encodable {
  final public func encode(to encoder: any Swift.Encoder) throws
}
extension RealmSwift.ObjectId : Swift.Comparable {
  public static func < (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
  public static func <= (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
  public static func >= (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
  public static func > (lhs: RealmSwift.ObjectId, rhs: RealmSwift.ObjectId) -> Swift.Bool
}
extension RealmSwift.ObjectiveCSupport {
  public static func convert(value: RealmSwift.AnyRealmValue?) -> (any RLMValue)?
  public static func convert(value: (any RLMValue)?) -> RealmSwift.AnyRealmValue
}
extension RealmSwift.ObjectiveCSupport {
  public static func convert(object: RealmSwift.AnyBSON?) -> (any RLMBSON)?
  public static func convert(object: (any RLMBSON)?) -> RealmSwift.AnyBSON?
  public static func convert(_ object: RealmSwift.Document) -> [Swift.String : any RLMBSON]
  public static func convertBson(object: RealmSwift.AnyBSON) -> any RLMBSON
  public static func convert(_ object: [Swift.String : any RLMBSON]) -> RealmSwift.Document
  public static func convertBson(object bson: any RLMBSON) -> RealmSwift.AnyBSON?
}
extension RealmSwift.ObjectiveCSupport {
  public static func convert(object: RealmSwift.SyncConfiguration) -> RLMSyncConfiguration
  public static func convert(object: RLMSyncConfiguration) -> RealmSwift.SyncConfiguration
  public static func convert(object: RealmSwift.Credentials) -> RLMCredentials
}
@frozen public struct ObjectiveCSupport {
  public static func convert<T>(object: RealmSwift.Results<T>) -> RLMResults<Swift.AnyObject> where T : RealmSwift.RealmCollectionValue
  public static func convert(object: RLMResults<Swift.AnyObject>) -> RealmSwift.Results<RealmSwift.Object>
  public static func convert<T>(object: RealmSwift.List<T>) -> RLMArray<Swift.AnyObject> where T : RealmSwift.RealmCollectionValue
  public static func convert<T>(object: RealmSwift.MutableSet<T>) -> RLMSet<Swift.AnyObject> where T : RealmSwift.RealmCollectionValue
  public static func convert(object: RLMArray<Swift.AnyObject>) -> RealmSwift.List<RealmSwift.Object>
  public static func convert(object: RLMSet<Swift.AnyObject>) -> RealmSwift.MutableSet<RealmSwift.Object>
  public static func convert<Key, Value>(object: RealmSwift.Map<Key, Value>) -> RLMDictionary<Swift.AnyObject, Swift.AnyObject> where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue
  public static func convert<Key>(object: RLMDictionary<Swift.AnyObject, Swift.AnyObject>) -> RealmSwift.Map<Key, RealmSwift.Object> where Key : RealmSwift._MapKey
  public static func convert<T>(object: RealmSwift.LinkingObjects<T>) -> RLMResults<Swift.AnyObject> where T : RLMObjectBase, T : RealmSwift.RealmCollectionValue
  public static func convert(object: RLMLinkingObjects<RLMObject>) -> RealmSwift.Results<RealmSwift.Object>
  public static func convert(object: RealmSwift.Realm) -> RLMRealm
  public static func convert(object: RLMRealm) -> RealmSwift.Realm
  @available(*, deprecated, message: "This function is now redundant")
  public static func convert(object: RealmSwift.Migration) -> RLMMigration
  public static func convert(object: RealmSwift.ObjectSchema) -> RLMObjectSchema
  public static func convert(object: RLMObjectSchema) -> RealmSwift.ObjectSchema
  public static func convert(object: RealmSwift.Property) -> RLMProperty
  public static func convert(object: RLMProperty) -> RealmSwift.Property
  public static func convert(object: RealmSwift.Realm.Configuration) -> RLMRealmConfiguration
  public static func convert(object: RLMRealmConfiguration) -> RealmSwift.Realm.Configuration
  public static func convert(object: RealmSwift.Schema) -> RLMSchema
  public static func convert(object: RLMSchema) -> RealmSwift.Schema
  public static func convert(object: RealmSwift.SortDescriptor) -> RLMSortDescriptor
  public static func convert(object: RLMSortDescriptor) -> RealmSwift.SortDescriptor
  @preconcurrency public static func convert(object: @escaping RLMShouldCompactOnLaunchBlock) -> @Sendable (Swift.Int, Swift.Int) -> Swift.Bool
  @preconcurrency public static func convert(object: @escaping @Sendable (Swift.Int, Swift.Int) -> Swift.Bool) -> RLMShouldCompactOnLaunchBlock
  @preconcurrency public static func convert(object: (@Sendable (RealmSwift.Realm) -> Swift.Void)?) -> RLMClientResetBeforeBlock?
  @preconcurrency public static func convert(object: RLMClientResetBeforeBlock?) -> (@Sendable (RealmSwift.Realm) -> Swift.Void)?
  @preconcurrency public static func convert(object: (@Sendable (RealmSwift.Realm, RealmSwift.Realm) -> Swift.Void)?) -> RLMClientResetAfterBlock?
  @preconcurrency public static func convert(object: RLMClientResetAfterBlock?) -> (@Sendable (RealmSwift.Realm, RealmSwift.Realm) -> Swift.Void)?
  @preconcurrency public static func convert(block: @escaping @Sendable (RealmSwift.SyncSubscriptionSet) -> Swift.Void) -> RLMFlexibleSyncInitialSubscriptionsBlock
  @preconcurrency public static func convert(block: RLMFlexibleSyncInitialSubscriptionsBlock?) -> (@Sendable (RealmSwift.SyncSubscriptionSet) -> Swift.Void)?
  @preconcurrency public static func convert(block: @escaping RLMFlexibleSyncInitialSubscriptionsBlock) -> @Sendable (RealmSwift.SyncSubscriptionSet) -> Swift.Void
}
@frozen public struct ObjectSchema : Swift.CustomStringConvertible {
  internal let rlmObjectSchema: RLMObjectSchema
  public var properties: [RealmSwift.Property] {
    get
  }
  public var className: Swift.String {
    get
  }
  public var objectClass: Swift.AnyClass {
    get
  }
  public var isEmbedded: Swift.Bool {
    get
  }
  public var isAsymmetric: Swift.Bool {
    get
  }
  public var primaryKeyProperty: RealmSwift.Property? {
    get
  }
  public var description: Swift.String {
    get
  }
  public subscript(propertyName: Swift.String) -> RealmSwift.Property? {
    get
  }
}
extension RealmSwift.ObjectSchema : Swift.Equatable {
  public static func == (lhs: RealmSwift.ObjectSchema, rhs: RealmSwift.ObjectSchema) -> Swift.Bool
}
public protocol RealmOptionalType : RealmSwift._ObjcBridgeable {
}
extension RealmSwift.RealmOptionalType {
  public static func className() -> Swift.String
}
extension Swift.Int : RealmSwift.RealmOptionalType {
}
extension Swift.Int8 : RealmSwift.RealmOptionalType {
}
extension Swift.Int16 : RealmSwift.RealmOptionalType {
}
extension Swift.Int32 : RealmSwift.RealmOptionalType {
}
extension Swift.Int64 : RealmSwift.RealmOptionalType {
}
extension Swift.Float : RealmSwift.RealmOptionalType {
}
extension Swift.Double : RealmSwift.RealmOptionalType {
}
extension Swift.Bool : RealmSwift.RealmOptionalType {
}
@available(*, deprecated, renamed: "RealmProperty", message: "RealmOptional<T> has been deprecated, use RealmProperty<T?> instead.")
final public class RealmOptional<Value> : RLMSwiftValueStorage where Value : RealmSwift.RealmOptionalType {
  final public var value: Value? {
    get
    set
  }
  public init(_ value: Value? = nil)
  @objc deinit
}
@available(*, deprecated, message: "RealmOptional has been deprecated, use RealmProperty<T?> instead.")
extension RealmSwift.RealmOptional : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: RealmSwift.RealmOptional<Value>, rhs: RealmSwift.RealmOptional<Value>) -> Swift.Bool
}
@available(*, deprecated, message: "RealmOptional has been deprecated, use RealmProperty<T?> instead.")
extension RealmSwift.RealmOptional : Swift.Codable where Value : RealmSwift._RealmSchemaDiscoverable, Value : Swift.Decodable, Value : Swift.Encodable {
  convenience public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
}
public typealias PropertyKey = Swift.UInt16
public protocol _HasPersistedType : RealmSwift._ObjcBridgeable {
  associatedtype PersistedType : RealmSwift._ObjcBridgeable
}
extension Foundation.NSNumber : RealmSwift._HasPersistedType {
  public typealias PersistedType = Foundation.NSNumber
}
extension Foundation.NSDate : RealmSwift._HasPersistedType {
  public typealias PersistedType = Foundation.NSDate
}
public protocol _Persistable : RealmSwift._HasPersistedType, RealmSwift._RealmSchemaDiscoverable where Self.PersistedType : RealmSwift._Persistable, Self.PersistedType.PersistedType == Self.PersistedType.PersistedType.PersistedType {
  static func _rlmGetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self
  static func _rlmSetProperty(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey, _ value: Self)
  static func _rlmSetAccessor(_ prop: RLMProperty)
  static var _rlmRequiresCaching: Swift.Bool { get }
  static func _rlmDefaultValue() -> Self
}
extension RealmSwift._Persistable {
  public static var _rlmRequiresCaching: Swift.Bool {
    get
  }
}
public protocol _PersistableInsideOptional : RealmSwift._Persistable where Self.PersistedType : RealmSwift._PersistableInsideOptional {
  static func _rlmGetPropertyOptional(_ obj: RealmSwift.ObjectBase, _ key: RealmSwift.PropertyKey) -> Self?
}
extension RealmSwift._PersistableInsideOptional {
  public static func _rlmSetAccessor(_ prop: RLMProperty)
}
public protocol _DefaultConstructible {
  init()
}
extension RealmSwift._Persistable where Self : RealmSwift._DefaultConstructible {
  public static func _rlmDefaultValue() -> Self
}
@propertyWrapper public struct Persisted<Value> where Value : RealmSwift._Persistable {
  @available(*, unavailable, message: "@Persisted can only be used as a property on a Realm object")
  public var wrappedValue: Value {
    get
    set
  }
  public init()
  public init(wrappedValue value: Value)
  public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, RealmSwift.Persisted<Value>>) -> Value where EnclosingSelf : RLMObjectBase {
    get
    set
  }
}
extension RealmSwift.Persisted : Swift.Decodable where Value : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension RealmSwift.Persisted : Swift.Encodable where Value : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol OptionalCodingWrapper {
  associatedtype WrappedType : Swift.ExpressibleByNilLiteral
  init(wrappedValue: Self.WrappedType)
}
extension Swift.KeyedDecodingContainer {
  public func decode<T>(_ type: T.Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> T where T : RealmSwift.OptionalCodingWrapper, T : Swift.Decodable
}
extension RealmSwift.Persisted : RealmSwift.OptionalCodingWrapper where Value : Swift.ExpressibleByNilLiteral {
  public typealias WrappedType = Value
}
public protocol PersistableEnum : RealmSwift.MinMaxType, RealmSwift.RealmEnum, RealmSwift._PersistableInsideOptional, RealmSwift._RealmCollectionValueInsideOptional, Swift.CaseIterable, Swift.Comparable, Swift.RawRepresentable where Self.RawValue : Swift.Comparable {
}
extension RealmSwift.PersistableEnum {
  public init()
  public static func < (lhs: Self, rhs: Self) -> Swift.Bool
  public static func _rlmDefaultValue() -> Self
}
@_marker public protocol _Indexable {
}
extension RealmSwift.Persisted where Value.PersistedType : RealmSwift._Indexable {
  public init(indexed: Swift.Bool)
  public init(wrappedValue value: Value, indexed: Swift.Bool)
}
@_marker public protocol _PrimaryKey {
}
extension RealmSwift.Persisted where Value.PersistedType : RealmSwift._PrimaryKey {
  public init(primaryKey: Swift.Bool)
  public init(wrappedValue value: Value, primaryKey: Swift.Bool)
}
public protocol LinkingObjectsProtocol {
  init(fromType: Self.Element.Type, property: Swift.String)
  associatedtype Element
}
extension RealmSwift.Persisted where Value : RealmSwift.LinkingObjectsProtocol {
  public init(originProperty: Swift.String)
}
extension RealmSwift.LinkingObjects : RealmSwift.LinkingObjectsProtocol {
}
extension RealmSwift.Persisted {
  public static var _rlmType: RealmSwift.PropertyType {
    get
  }
  public static var _rlmOptional: Swift.Bool {
    get
  }
  public static var _rlmRequireObjc: Swift.Bool {
    get
  }
  public static func _rlmPopulateProperty(_ prop: RLMProperty)
  public func _rlmPopulateProperty(_ prop: RLMProperty)
}
@propertyWrapper public struct Projected<T, Value> where T : RLMObjectBase {
  @available(*, unavailable, message: "@Persisted can only be used as a property on a Realm object")
  public var wrappedValue: Value {
    get
    set
  }
  public static subscript<EnclosingSelf>(_enclosingInstance observed: EnclosingSelf, wrapped wrappedKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, Value>, storage storageKeyPath: Swift.ReferenceWritableKeyPath<EnclosingSelf, RealmSwift.Projected<T, Value>>) -> Value where T : RealmSwift.RealmCollectionValue, T : RealmSwift.ThreadConfined, EnclosingSelf : RealmSwift.Projection<T> {
    get
    set
  }
  public init(_ projectedKeyPath: Swift.KeyPath<T, Value>)
}
public protocol ProjectionObservable : AnyObject, RealmSwift.ThreadConfined {
  associatedtype Root : RLMObjectBase
  var rootObject: Self.Root { get }
  init(projecting object: Self.Root)
}
open class Projection<Root> : RealmSwift.RealmCollectionValue, RealmSwift.ProjectionObservable where Root : RLMObjectBase, Root : RealmSwift.RealmCollectionValue, Root : RealmSwift.ThreadConfined {
  public typealias PersistedType = Root
  final public let rootObject: Root
  required public init(projecting object: Root)
  public static func == (lhs: RealmSwift.Projection<Root>, rhs: RealmSwift.Projection<Root>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  open var description: Swift.String {
    get
  }
  public static func _rlmDefaultValue() -> Self
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
extension RealmSwift.ProjectionObservable {
  public func observe(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  public func observe(keyPaths: [Swift.PartialKeyPath<Self>], on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.ObjectChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.String]? = nil, on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.ObjectChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.PartialKeyPath<Self>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.ObjectChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
}
@frozen public struct ProjectedPropertyChange {
  public let name: Swift.String
  public let oldValue: Any?
  public let newValue: Any?
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Projection {
  public func addObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String, options: Foundation.NSKeyValueObservingOptions = [], context: Swift.UnsafeMutableRawPointer?)
  public func removeObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String, context: Swift.UnsafeMutableRawPointer?)
  public func removeObserver(_ observer: ObjectiveC.NSObject, forKeyPath keyPath: Swift.String)
}
extension RealmSwift.Projection : RealmSwift.ThreadConfined {
  public var realm: RealmSwift.Realm? {
    get
  }
  public var isInvalidated: Swift.Bool {
    get
  }
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> Self
  public func thaw() -> Self?
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ProjectionObservable {
  public func _observe<S>(_ keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue?, _ subscriber: S) -> RealmSwift.NotificationToken where Self == S.Input, S : Combine.Subscriber
  public func _observe<S>(_ keyPaths: [Swift.String]?, _ subscriber: S) -> RealmSwift.NotificationToken where S : Combine.Subscriber, S.Input == ()
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Projection : Combine.ObservableObject, RealmSwift.RealmSubscribable {
  public var objectWillChange: RealmSwift.RealmPublishers.WillChange<RealmSwift.Projection<Root>> {
    get
  }
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = RealmSwift.RealmPublishers.WillChange<RealmSwift.Projection<Root>>
}
@usableFromInline
@propertyWrapper internal struct Unchecked<Wrapped> : @unchecked Swift.Sendable {
  public var wrappedValue: Wrapped
  public init(wrappedValue: Wrapped)
  public init(_ wrappedValue: Wrapped)
}
@frozen public struct Property : Swift.CustomStringConvertible {
  internal let rlmProperty: RLMProperty
  public var name: Swift.String {
    get
  }
  public var columnName: Swift.String {
    get
  }
  public var type: RealmSwift.PropertyType {
    get
  }
  public var isArray: Swift.Bool {
    get
  }
  public var isSet: Swift.Bool {
    get
  }
  public var isMap: Swift.Bool {
    get
  }
  public var isIndexed: Swift.Bool {
    get
  }
  public var isOptional: Swift.Bool {
    get
  }
  public var objectClassName: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension RealmSwift.Property : Swift.Equatable {
  public static func == (lhs: RealmSwift.Property, rhs: RealmSwift.Property) -> Swift.Bool
}
public struct StringOptions : Swift.OptionSet, Swift.Sendable {
  public let rawValue: Swift.Int8
  public init(rawValue: Swift.Int8)
  public static let caseInsensitive: RealmSwift.StringOptions
  public static let diacriticInsensitive: RealmSwift.StringOptions
  public typealias ArrayLiteralElement = RealmSwift.StringOptions
  public typealias Element = RealmSwift.StringOptions
  public typealias RawValue = Swift.Int8
}
@dynamicMemberLookup public struct Query<T> {
  public static func == (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func == (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func != (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func != (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public func `in`<U>(_ collection: U) -> RealmSwift.Query<Swift.Bool> where T == U.Element, U : Swift.Sequence
  public subscript<V>(dynamicMember member: Swift.KeyPath<T, V>) -> RealmSwift.Query<V> where T : RLMObjectBase {
    get
  }
  public subscript<V>(dynamicMember member: Swift.KeyPath<T, V>) -> RealmSwift.Query<V> where T : RLMObjectBase, V : RealmSwift.RealmKeyedCollection {
    get
  }
  public subscript<V>(dynamicMember member: Swift.KeyPath<T, V>) -> RealmSwift.Query<V> where T : RLMObjectBase, V : RealmSwift.RealmCollectionBase {
    get
  }
  public static func _constructForTesting() -> RealmSwift.Query<T>
  public func _constructPredicate() -> (Swift.String, [Any])
}
extension RealmSwift.Query where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift._QueryNumeric {
  public static func > (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func > (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func >= (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func >= (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func < (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func < (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func <= (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func <= (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T == Swift.Bool {
  prefix public static func ! (query: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func && (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func || (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T == RealmSwift.AnyRealmValue {
  public subscript(position: Swift.Int) -> RealmSwift.Query<RealmSwift.AnyRealmValue> {
    get
  }
  public subscript(key: Swift.String) -> RealmSwift.Query<RealmSwift.AnyRealmValue> {
    get
  }
  public var any: RealmSwift.Query<RealmSwift.AnyRealmValue> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.OptionalProtocol {
  public subscript<V>(dynamicMember member: Swift.KeyPath<T.Wrapped, V>) -> RealmSwift.Query<V> where T.Wrapped : RLMObjectBase {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection {
  public subscript<V>(dynamicMember member: Swift.KeyPath<T.Element, V>) -> RealmSwift.Query<V> where T.Element : RLMObjectBase {
    get
  }
  public var count: RealmSwift.Query<Swift.Int> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection {
  public func contains(_ value: T.Element) -> RealmSwift.Query<Swift.Bool>
  public func containsAny<U>(in collection: U) -> RealmSwift.Query<Swift.Bool> where U : Swift.Sequence, T.Element == U.Element
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection, T.Element : Swift.Comparable {
  public func contains(_ range: Swift.Range<T.Element>) -> RealmSwift.Query<Swift.Bool>
  public func contains(_ range: Swift.ClosedRange<T.Element>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection, T.Element : RealmSwift.OptionalProtocol, T.Element.Wrapped : Swift.Comparable {
  public func contains(_ range: Swift.Range<T.Element.Wrapped>) -> RealmSwift.Query<Swift.Bool>
  public func contains(_ range: Swift.ClosedRange<T.Element.Wrapped>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection {
  public static func == (lhs: RealmSwift.Query<T>, rhs: T.Element) -> RealmSwift.Query<Swift.Bool>
  public static func != (lhs: RealmSwift.Query<T>, rhs: T.Element) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection, T.Element.PersistedType : RealmSwift._QueryNumeric {
  public static func > (lhs: RealmSwift.Query<T>, rhs: T.Element) -> RealmSwift.Query<Swift.Bool>
  public static func >= (lhs: RealmSwift.Query<T>, rhs: T.Element) -> RealmSwift.Query<Swift.Bool>
  public static func < (lhs: RealmSwift.Query<T>, rhs: T.Element) -> RealmSwift.Query<Swift.Bool>
  public static func <= (lhs: RealmSwift.Query<T>, rhs: T.Element) -> RealmSwift.Query<Swift.Bool>
  public var min: RealmSwift.Query<T.Element> {
    get
  }
  public var max: RealmSwift.Query<T.Element> {
    get
  }
  public var avg: RealmSwift.Query<T.Element> {
    get
  }
  public var sum: RealmSwift.Query<T.Element> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection {
  public func containsAny<U>(in collection: U) -> RealmSwift.Query<Swift.Bool> where U : Swift.Sequence, T.Value == U.Element
  public func contains(_ value: T.Value) -> RealmSwift.Query<Swift.Bool>
  public var values: RealmSwift.Query<T.Value> {
    get
  }
  public subscript(member: T.Key) -> RealmSwift.Query<T.Value> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection, T.Key == Swift.String {
  public var keys: RealmSwift.Query<Swift.String> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection, T.Value : Swift.Comparable {
  public func contains(_ range: Swift.Range<T.Value>) -> RealmSwift.Query<Swift.Bool>
  public func contains(_ range: Swift.ClosedRange<T.Value>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection, T.Value : RealmSwift.OptionalProtocol, T.Value.Wrapped : Swift.Comparable {
  public func contains(_ range: Swift.Range<T.Value.Wrapped>) -> RealmSwift.Query<Swift.Bool>
  public func contains(_ range: Swift.ClosedRange<T.Value.Wrapped>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection, T.Value.PersistedType : RealmSwift._QueryNumeric {
  public var min: RealmSwift.Query<T.Value> {
    get
  }
  public var max: RealmSwift.Query<T.Value> {
    get
  }
  public var avg: RealmSwift.Query<T.Value> {
    get
  }
  public var sum: RealmSwift.Query<T.Value> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection {
  public var count: RealmSwift.Query<Swift.Int> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.PersistableEnum, T.RawValue : RealmSwift._RealmSchemaDiscoverable {
  public var rawValue: RealmSwift.Query<T.RawValue> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.OptionalProtocol, T.Wrapped : RealmSwift.PersistableEnum, T.Wrapped.RawValue : RealmSwift._RealmSchemaDiscoverable {
  public var rawValue: RealmSwift.Query<T.Wrapped.RawValue?> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection, T.Element : RealmSwift.PersistableEnum, T.Element.RawValue : RealmSwift.RealmCollectionValue {
  public var rawValue: RealmSwift.Query<RealmSwift.AnyRealmCollection<T.Element.RawValue>> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection, T.Value : RealmSwift.PersistableEnum, T.Value.RawValue : RealmSwift.RealmCollectionValue {
  public var rawValue: RealmSwift.Query<RealmSwift.Map<T.Key, T.Value.RawValue>> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection, T.Element : RealmSwift.OptionalProtocol, T.Element.Wrapped : RealmSwift.PersistableEnum, T.Element.Wrapped.RawValue : RealmSwift._RealmCollectionValueInsideOptional {
  public var rawValue: RealmSwift.Query<RealmSwift.AnyRealmCollection<T.Element.Wrapped.RawValue?>> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection, T.Value : RealmSwift.OptionalProtocol, T.Value.Wrapped : RealmSwift.PersistableEnum, T.Value.Wrapped.RawValue : RealmSwift._RealmCollectionValueInsideOptional {
  public var rawValue: RealmSwift.Query<RealmSwift.Map<T.Key, T.Value.Wrapped.RawValue?>> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift._HasPersistedType {
  public var persistableValue: RealmSwift.Query<T.PersistedType> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmCollection {
  public var persistableValue: RealmSwift.Query<RealmSwift.AnyRealmCollection<T.Element.PersistedType>> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.RealmKeyedCollection {
  public var persistableValue: RealmSwift.Query<RealmSwift.Map<T.Key, T.Value.PersistedType>> {
    get
  }
}
extension RealmSwift.Query where T : Swift.Comparable {
  public func contains(_ range: Swift.Range<T>) -> RealmSwift.Query<Swift.Bool>
  public func contains(_ range: Swift.ClosedRange<T>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift._QueryString {
  public func like(_ value: T, caseInsensitive: Swift.Bool = false) -> RealmSwift.Query<Swift.Bool>
  public func like<U>(_ column: RealmSwift.Query<U>, caseInsensitive: Swift.Bool = false) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift._QueryBinary {
  public func contains(_ value: T, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func contains<U>(_ column: RealmSwift.Query<U>, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool> where U : RealmSwift._Persistable, U.PersistedType : RealmSwift._QueryBinary
  public func starts(with value: T, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func starts<U>(with column: RealmSwift.Query<U>, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func ends(with value: T, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func ends<U>(with column: RealmSwift.Query<U>, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func equals(_ value: T, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func equals<U>(_ column: RealmSwift.Query<U>, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func notEquals(_ value: T, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public func notEquals<U>(_ column: RealmSwift.Query<U>, options: RealmSwift.StringOptions = []) -> RealmSwift.Query<Swift.Bool>
  public static func > (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func > (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func >= (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func >= (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func < (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func < (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public static func <= (lhs: RealmSwift.Query<T>, rhs: T) -> RealmSwift.Query<Swift.Bool>
  public static func <= (lhs: RealmSwift.Query<T>, rhs: RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T : RealmSwift.OptionalProtocol, T.Wrapped : Swift.Comparable {
  public func contains(_ range: Swift.Range<T.Wrapped>) -> RealmSwift.Query<Swift.Bool>
  public func contains(_ range: Swift.ClosedRange<T.Wrapped>) -> RealmSwift.Query<Swift.Bool>
}
extension RealmSwift.Query where T == Swift.Bool {
  public var count: RealmSwift.Query<Swift.Int> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift._QueryNumeric {
  public var min: RealmSwift.Query<T> {
    get
  }
  public var max: RealmSwift.Query<T> {
    get
  }
  public var avg: RealmSwift.Query<T> {
    get
  }
  public var sum: RealmSwift.Query<T> {
    get
  }
}
extension RealmSwift.Query where T : RealmSwift.OptionalProtocol, T.Wrapped : RealmSwiftEmbeddedObject {
  public func geoWithin<U>(_ value: U) -> RealmSwift.Query<Swift.Bool> where U : RLMGeospatial
}
public protocol _QueryNumeric : RealmSwift._RealmSchemaDiscoverable {
}
extension Swift.Int : RealmSwift._QueryNumeric {
}
extension Swift.Int8 : RealmSwift._QueryNumeric {
}
extension Swift.Int16 : RealmSwift._QueryNumeric {
}
extension Swift.Int32 : RealmSwift._QueryNumeric {
}
extension Swift.Int64 : RealmSwift._QueryNumeric {
}
extension Swift.Float : RealmSwift._QueryNumeric {
}
extension Swift.Double : RealmSwift._QueryNumeric {
}
extension RealmSwift.Decimal128 : RealmSwift._QueryNumeric {
}
extension Foundation.Date : RealmSwift._QueryNumeric {
}
extension RealmSwift.AnyRealmValue : RealmSwift._QueryNumeric {
}
extension Swift.Optional : RealmSwift._QueryNumeric where Wrapped : RealmSwift._Persistable, Wrapped.PersistedType : RealmSwift._QueryNumeric {
}
public protocol _QueryString : RealmSwift._QueryBinary {
}
extension Swift.String : RealmSwift._QueryString {
}
extension Swift.Optional : RealmSwift._QueryString where Wrapped : RealmSwift._Persistable, Wrapped.PersistedType : RealmSwift._QueryString {
}
public protocol _QueryBinary {
}
extension Foundation.Data : RealmSwift._QueryBinary {
}
extension Swift.Optional : RealmSwift._QueryBinary where Wrapped : RealmSwift._Persistable, Wrapped.PersistedType : RealmSwift._QueryBinary {
}
public typealias AsyncTransactionId = RLMAsyncTransactionId
@frozen public struct Realm {
  public var schema: RealmSwift.Schema {
    get
  }
  public var configuration: RealmSwift.Realm.Configuration {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public init(queue: Dispatch.DispatchQueue? = nil) throws
  public init(configuration: RealmSwift.Realm.Configuration, queue: Dispatch.DispatchQueue? = nil) throws
  public init(fileURL: Foundation.URL) throws
  @discardableResult
  public static func asyncOpen(configuration: RealmSwift.Realm.Configuration = .defaultConfiguration, callbackQueue: Dispatch.DispatchQueue = .main, callback: @escaping (Swift.Result<RealmSwift.Realm, any Swift.Error>) -> Swift.Void) -> RealmSwift.Realm.AsyncOpenTask
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public static func asyncOpen(configuration: RealmSwift.Realm.Configuration = .defaultConfiguration) -> RealmSwift.RealmPublishers.AsyncOpenPublisher
  @frozen public struct AsyncOpenTask {
    internal let rlmTask: RLMAsyncOpenTask
    public func cancel()
    public func addProgressNotification(queue: Dispatch.DispatchQueue = .main, block: @escaping (RealmSwift.SyncSession.Progress) -> Swift.Void)
  }
  @discardableResult
  public func write<Result>(withoutNotifying tokens: [RealmSwift.NotificationToken] = [], _ block: () throws -> Result) throws -> Result
  public func beginWrite()
  public func commitWrite(withoutNotifying tokens: [RealmSwift.NotificationToken] = []) throws
  public func cancelWrite()
  public var isInWriteTransaction: Swift.Bool {
    get
  }
  @discardableResult
  public func writeAsync(_ block: @escaping () -> Swift.Void, onComplete: (((any Swift.Error)?) -> Swift.Void)? = nil) -> RealmSwift.AsyncTransactionId
  @discardableResult
  public func beginAsyncWrite(_ asyncWriteBlock: @escaping () -> Swift.Void) -> RealmSwift.AsyncTransactionId
  @discardableResult
  public func commitAsyncWrite(allowGrouping: Swift.Bool = false, _ onComplete: (((any Swift.Error)?) -> Swift.Void)? = nil) -> RealmSwift.AsyncTransactionId
  public func cancelAsyncWrite(_ asyncTransactionId: RealmSwift.AsyncTransactionId) throws
  public var isPerformingAsynchronousWriteOperations: Swift.Bool {
    get
  }
  @frozen public enum UpdatePolicy : Swift.Int {
    case error
    case modified
    case all
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
  public func add(_ object: RealmSwift.Object, update: Swift.Bool)
  public func add(_ object: RealmSwift.Object, update: RealmSwift.Realm.UpdatePolicy = .error)
  @available(*, unavailable, message: "Pass .error, .modified or .all rather than a boolean. .error is equivalent to false and .all is equivalent to true.")
  public func add<S>(_ objects: S, update: Swift.Bool) where S : Swift.Sequence, S.Element : RealmSwiftObject
  public func add<S>(_ objects: S, update: RealmSwift.Realm.UpdatePolicy = .error) where S : Swift.Sequence, S.Element : RealmSwiftObject
  @discardableResult
  public func create<T>(_ type: T.Type, value: Any = [String: Any](), update: RealmSwift.Realm.UpdatePolicy = .error) -> T where T : RealmSwiftObject
  @discardableResult
  public func dynamicCreate(_ typeName: Swift.String, value: Any = [String: Any](), update: RealmSwift.Realm.UpdatePolicy = .error) -> RealmSwift.DynamicObject
  public func delete(_ object: RealmSwift.ObjectBase)
  public func delete<S>(_ objects: S) where S : Swift.Sequence, S.Element : RLMObjectBase
  public func delete<Element>(_ objects: RealmSwift.List<Element>) where Element : RLMObjectBase, Element : RealmSwift.RealmCollectionValue
  public func delete<Key, Value>(_ map: RealmSwift.Map<Key, Value?>) where Key : RealmSwift._MapKey, Value : RLMObjectBase, Value : RealmSwift._RealmCollectionValueInsideOptional
  public func delete<Element>(_ objects: RealmSwift.Results<Element>) where Element : RLMObjectBase, Element : RealmSwift.RealmCollectionValue
  public func deleteAll()
  public func objects<Element>(_ type: Element.Type) -> RealmSwift.Results<Element> where Element : RealmSwift.RealmFetchable
  public func dynamicObjects(_ typeName: Swift.String) -> RealmSwift.Results<RealmSwift.DynamicObject>
  public func object<Element, KeyType>(ofType type: Element.Type, forPrimaryKey key: KeyType) -> Element? where Element : RealmSwiftObject
  public func dynamicObject(ofType typeName: Swift.String, forPrimaryKey key: Any) -> RealmSwift.DynamicObject?
  public func observe(_ block: @escaping RealmSwift.NotificationBlock) -> RealmSwift.NotificationToken
  public var autorefresh: Swift.Bool {
    get
    nonmutating set
  }
  @discardableResult
  public func refresh() -> Swift.Bool
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> RealmSwift.Realm
  public func thaw() -> RealmSwift.Realm
  public func freeze<T>(_ obj: T) -> T where T : RLMObjectBase
  public func thaw<T>(_ obj: T) -> T? where T : RLMObjectBase
  public func freeze<Collection>(_ collection: Collection) -> Collection where Collection : RealmSwift.RealmCollection
  public func invalidate()
  public func writeCopy(toFile fileURL: Foundation.URL, encryptionKey: Foundation.Data? = nil) throws
  public func writeCopy(configuration: RealmSwift.Realm.Configuration) throws
  public static func fileExists(for config: RealmSwift.Realm.Configuration) -> Swift.Bool
  public static func deleteFiles(for config: RealmSwift.Realm.Configuration) throws -> Swift.Bool
  internal var rlmRealm: RLMRealm
}
extension RealmSwift.Realm {
  public var subscriptions: RealmSwift.SyncSubscriptionSet {
    get
  }
}
extension RealmSwift.Realm {
  public func create<T>(_ type: T.Type, value: Any = [String: Any]()) where T : RealmSwiftAsymmetricObject
}
extension RealmSwift.Realm : Swift.Equatable {
  public static func == (lhs: RealmSwift.Realm, rhs: RealmSwift.Realm) -> Swift.Bool
}
extension RealmSwift.Realm {
  @frozen public enum Notification : Swift.String {
    case didChange
    case refreshRequired
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public typealias NotificationBlock = (_ notification: RealmSwift.Realm.Notification, _ realm: RealmSwift.Realm) -> Swift.Void
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Realm {
  @frozen public enum OpenBehavior : Swift.Sendable {
    case never
    case always
    case once
    public static func == (a: RealmSwift.Realm.OpenBehavior, b: RealmSwift.Realm.OpenBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor public init(configuration: RealmSwift.Realm.Configuration = .defaultConfiguration, downloadBeforeOpen: RealmSwift.Realm.OpenBehavior = .never) async throws
  public init<A>(configuration: RealmSwift.Realm.Configuration = .defaultConfiguration, actor: A, downloadBeforeOpen: RealmSwift.Realm.OpenBehavior = .never) async throws where A : _Concurrency.Actor
  public static func open(configuration: RealmSwift.Realm.Configuration = .defaultConfiguration, _isolation actor: isolated any _Concurrency.Actor = #isolation, downloadBeforeOpen: RealmSwift.Realm.OpenBehavior = .never) async throws -> RealmSwift.Realm
  @discardableResult
  public func asyncWrite<Result>(_isolation actor: isolated any _Concurrency.Actor = #isolation, _ block: () throws -> Result) async throws -> Result
  @discardableResult
  public func asyncRefresh(_isolation: isolated any _Concurrency.Actor = #isolation) async -> Swift.Bool
}
public protocol RealmFetchable : RealmSwift.RealmCollectionValue {
  static func className() -> Swift.String
}
extension RealmSwiftObject : RealmSwift.RealmFetchable {
}
extension RealmSwift.Projection : RealmSwift.RealmFetchable {
  public static func className() -> Swift.String
}
public typealias Logger = RLMLogger
@frozen public struct RLMIterator<Element> : Swift.IteratorProtocol where Element : RealmSwift.RealmCollectionValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  public mutating func next() -> Element?
}
public protocol _RealmMapValue {
  associatedtype Key : RealmSwift._MapKey
  associatedtype Value : RealmSwift.RealmCollectionValue
}
@frozen public struct RLMMapIterator<Element> : Swift.IteratorProtocol where Element : RealmSwift._RealmMapValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  private var collection: RLMDictionary<Swift.AnyObject, Swift.AnyObject>
  public mutating func next() -> Element?
}
@frozen public struct RLMKeyValueIterator<Key, Value> : Swift.IteratorProtocol where Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  private var collection: RLMDictionary<Swift.AnyObject, Swift.AnyObject>
  public typealias Element = (key: Key, value: Value)
  public mutating func next() -> RealmSwift.RLMKeyValueIterator<Key, Value>.Element?
}
@frozen public enum RealmCollectionChange<CollectionType> {
  case initial(CollectionType)
  case update(CollectionType, deletions: [Swift.Int], insertions: [Swift.Int], modifications: [Swift.Int])
  case error(any Swift.Error)
}
public protocol RealmCollectionValue : RealmSwift._HasPersistedType, Swift.Hashable where Self.PersistedType : RealmSwift.RealmCollectionValue {
  static func _rlmDefaultValue() -> Self
}
public protocol _RealmCollectionValueInsideOptional : RealmSwift.RealmCollectionValue where Self.PersistedType : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Int : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Int8 : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Int16 : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Int32 : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Int64 : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Float : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Double : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.Bool : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Swift.String : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Foundation.Date : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Foundation.Data : RealmSwift._RealmCollectionValueInsideOptional {
}
extension RealmSwift.Decimal128 : RealmSwift._RealmCollectionValueInsideOptional {
}
extension RealmSwift.ObjectId : RealmSwift._RealmCollectionValueInsideOptional {
}
extension Foundation.UUID : RealmSwift._RealmCollectionValueInsideOptional {
}
extension RealmSwift.AnyRealmValue : RealmSwift.RealmCollectionValue {
}
extension Swift.Optional : RealmSwift.RealmCollectionValue where Wrapped : RealmSwift._RealmCollectionValueInsideOptional {
  public static func _rlmDefaultValue() -> Swift.Optional<Wrapped>
}
public protocol RealmCollectionBase : RealmSwift.ThreadConfined, Swift.CustomStringConvertible, Swift.LazyCollectionProtocol, Swift.RandomAccessCollection where Self.Element : RealmSwift.RealmCollectionValue {
  typealias ElementType = Self.Element
}
public protocol RealmCollection : RealmSwift.RealmCollectionBase, Swift.Equatable where Self.Iterator == RealmSwift.RLMIterator<Self.Element> {
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var count: Swift.Int { get }
  var description: Swift.String { get }
  var first: Self.Element? { get }
  var last: Self.Element? { get }
  func index(of object: Self.Element) -> Swift.Int?
  func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  func index(matching predicateFormat: Swift.String, _ args: Any...) -> Swift.Int?
  func objects(at indexes: Foundation.IndexSet) -> [Self.Element]
  func filter(_ predicateFormat: Swift.String, _ args: Any...) -> RealmSwift.Results<Self.Element>
  func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Self.Element>
  func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Self.Element> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  func distinct<S>(by keyPaths: S) -> RealmSwift.Results<Self.Element> where S : Swift.Sequence, S.Element == Swift.String
  func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  func value(forKey key: Swift.String) -> Any?
  func value(forKeyPath keyPath: Swift.String) -> Any?
  func setValue(_ value: Any?, forKey key: Swift.String)
  func observe(keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  func observe<A>(keyPaths: [Swift.String]?, on actor: A, _isolation: isolated (any _Concurrency.Actor)?, _ block: @escaping @Sendable (isolated A, RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
  func sectioned<Key>(sortDescriptors: [RealmSwift.SortDescriptor], _ keyBlock: @escaping (Self.Element) -> Key) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable
}
extension RealmSwift.RealmCollection where Self.Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension RealmSwift.RealmCollection {
  public func index(matching isIncluded: (RealmSwift.Query<Self.Element>) -> RealmSwift.Query<Swift.Bool>) -> Swift.Int? where Self.Element : RealmSwift._RealmSchemaDiscoverable
  public func `where`(_ isIncluded: (RealmSwift.Query<Self.Element>) -> RealmSwift.Query<Swift.Bool>) -> RealmSwift.Results<Self.Element>
}
extension RealmSwift.RealmCollection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public func index(before i: Swift.Int) -> Swift.Int
}
extension RealmSwift.RealmCollection where Self.Element : RLMObjectBase {
  public func min<T>(of keyPath: Swift.KeyPath<Self.Element, T>) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  public func max<T>(of keyPath: Swift.KeyPath<Self.Element, T>) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  public func sum<T>(of keyPath: Swift.KeyPath<Self.Element, T>) -> T where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  public func average<T>(of keyPath: Swift.KeyPath<Self.Element, T>) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  public func sectioned<Key>(by keyPath: Swift.KeyPath<Self.Element, Key>, ascending: Swift.Bool = true) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable
  public func sectioned<Key>(by keyPath: Swift.KeyPath<Self.Element, Key>, sortDescriptors: [RealmSwift.SortDescriptor]) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable
  public func sectioned<Key>(by block: @escaping (Self.Element) -> Key, sortDescriptors: [RealmSwift.SortDescriptor]) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable
}
extension RealmSwift.RealmCollection where Self.Element.PersistedType : RealmSwift.MinMaxType {
  public func min() -> Self.Element?
  public func max() -> Self.Element?
}
extension RealmSwift.RealmCollection where Self.Element.PersistedType : RealmSwift.AddableType {
  public func sum() -> Self.Element
  public func average<T>() -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
}
extension RealmSwift.RealmCollection where Self.Element : RealmSwift.KeypathSortable {
  public func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Element>
  public func sorted<T>(by keyPath: Swift.KeyPath<Self.Element, T>, ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Element> where T : RealmSwift._HasPersistedType, Self.Element : RLMObjectBase, T.PersistedType : RealmSwift.SortableType
  public func distinct<S>(by keyPaths: S) -> RealmSwift.Results<Self.Element> where S : Swift.Sequence, Self.Element : RLMObjectBase, S.Element == Swift.PartialKeyPath<Self.Element>
}
extension RealmSwift.RealmCollection where Self.Element.PersistedType : RealmSwift.SortableType {
  public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Element>
  public func distinct() -> RealmSwift.Results<Self.Element>
}
extension RealmSwift.RealmCollection {
  public func sectioned<Key>(by block: @escaping (Self.Element) -> Key, ascending: Swift.Bool = true) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable
}
extension RealmSwift.RealmCollection {
  public func index(matching predicateFormat: Swift.String, _ args: Any...) -> Swift.Int?
  public func filter(_ predicateFormat: Swift.String, _ args: Any...) -> RealmSwift.Results<Self.Element>
}
extension RealmSwift.RealmCollection {
  public func observe(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.String]? = nil, on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
}
extension RealmSwift.RealmCollection where Self.Element : RLMObjectBase {
  public func observe(keyPaths: [Swift.PartialKeyPath<Self.Element>], on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.PartialKeyPath<Self.Element>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.RealmCollectionChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
}
extension RealmSwift.RealmCollection {
  public func sectioned<Key, O>(by keyPath: Swift.KeyPath<Self.Element, Key>, ascending: Swift.Bool = true) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable, O : RLMObjectBase, O : RealmSwift.ThreadConfined, Self.Element : RealmSwift.Projection<O>
  public func sectioned<Key, O>(by keyPath: Swift.KeyPath<Self.Element, Key>, sortDescriptors: [RealmSwift.SortDescriptor]) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable, O : RLMObjectBase, O : RealmSwift.ThreadConfined, Self.Element : RealmSwift.Projection<O>
  public func sectioned<Key, O>(by block: @escaping (Self.Element) -> Key, sortDescriptors: [RealmSwift.SortDescriptor]) -> RealmSwift.SectionedResults<Key, Self.Element> where Key : RealmSwift._Persistable, Key : Swift.Hashable, O : RLMObjectBase, O : RealmSwift.ThreadConfined, Self.Element : RealmSwift.Projection<O>
}
@frozen public struct AnyRealmCollection<Element> where Element : RealmSwift.RealmCollectionValue {
  internal let collection: any RLMCollection
  internal var lastAccessedNames: Foundation.NSMutableArray?
  public init<C>(_ base: C) where Element == C.Element, C : RealmSwift.RealmCollection, C : RealmSwift._ObjcBridgeable
  public subscript(position: Swift.Int) -> Element {
    get
  }
  public var description: Swift.String {
    get
  }
  public static func == (lhs: RealmSwift.AnyRealmCollection<Element>, rhs: RealmSwift.AnyRealmCollection<Element>) -> Swift.Bool
  public func makeIterator() -> RealmSwift.RLMIterator<Element>
  public typealias Elements = RealmSwift.AnyRealmCollection<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.AnyRealmCollection<Element>>
}
extension RealmSwift.AnyRealmCollection : Swift.Encodable where Element : Swift.Encodable {
}
public struct ProjectedCollection<Element> : Swift.RandomAccessCollection, Swift.CustomStringConvertible, RealmSwift.ThreadConfined where Element : RealmSwift.RealmCollectionValue {
  public typealias Index = Swift.Int
  public func index(matching predicate: Foundation.NSPredicate) -> Swift.Int?
  public func observe(on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.ProjectedCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public func observe(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmCollectionChange<RealmSwift.ProjectedCollection<Element>>) -> Swift.Void) -> RealmSwift.NotificationToken
  public subscript(position: Swift.Int) -> Element {
    get
    set
  }
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public var realm: RealmSwift.Realm? {
    get
  }
  public var isInvalidated: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
  public func index(of object: Element) -> Swift.Int?
  public var isFrozen: Swift.Bool {
    get
  }
  public func freeze() -> RealmSwift.ProjectedCollection<Element>
  public func thaw() -> RealmSwift.ProjectedCollection<Element>?
  public typealias Indices = Swift.Range<RealmSwift.ProjectedCollection<Element>.Index>
  public typealias Iterator = Swift.IndexingIterator<RealmSwift.ProjectedCollection<Element>>
  public typealias SubSequence = Swift.Slice<RealmSwift.ProjectedCollection<Element>>
}
@dynamicMemberLookup public struct CollectionElementMapper<Element> where Element : RLMObjectBase, Element : RealmSwift.RealmCollectionValue {
  public subscript<V>(dynamicMember member: Swift.KeyPath<Element, V>) -> RealmSwift.ProjectedCollection<V> where V : RealmSwift.RealmCollectionValue {
    get
  }
}
extension RealmSwift.List where Element : RLMObjectBase {
  final public var projectTo: RealmSwift.CollectionElementMapper<Element> {
    get
  }
}
extension RealmSwift.MutableSet where Element : RLMObjectBase {
  final public var projectTo: RealmSwift.CollectionElementMapper<Element> {
    get
  }
}
public protocol OptionalProtocol {
  associatedtype Wrapped
  func _rlmInferWrappedType() -> Self.Wrapped
}
extension Swift.Optional : RealmSwift.OptionalProtocol {
  public func _rlmInferWrappedType() -> Wrapped
}
extension RealmSwift.Realm {
  @frozen public struct Configuration : Swift.Sendable {
    public static var defaultConfiguration: RealmSwift.Realm.Configuration {
      get
      set
    }
    @preconcurrency public init(fileURL: Foundation.URL? = URL(fileURLWithPath: RLMRealmPathForFile("default.realm"), isDirectory: false), inMemoryIdentifier: Swift.String? = nil, syncConfiguration: RealmSwift.SyncConfiguration? = nil, encryptionKey: Foundation.Data? = nil, readOnly: Swift.Bool = false, schemaVersion: Swift.UInt64 = 0, migrationBlock: RealmSwift.MigrationBlock? = nil, deleteRealmIfMigrationNeeded: Swift.Bool = false, shouldCompactOnLaunch: (@Sendable (Swift.Int, Swift.Int) -> Swift.Bool)? = nil, objectTypes: [RealmSwift.ObjectBase.Type]? = nil, seedFilePath: Foundation.URL? = nil)
    public var syncConfiguration: RealmSwift.SyncConfiguration? {
      get
      set
    }
    private var _syncConfiguration: RealmSwift.SyncConfiguration?
    @_hasStorage public var fileURL: Foundation.URL? {
      get
      set
    }
    public var inMemoryIdentifier: Swift.String? {
      get
      set
    }
    private var _inMemoryIdentifier: Swift.String?
    public var encryptionKey: Foundation.Data?
    public var readOnly: Swift.Bool = false
    public var schemaVersion: Swift.UInt64 = 0
    @preconcurrency public var migrationBlock: RealmSwift.MigrationBlock?
    public var deleteRealmIfMigrationNeeded: Swift.Bool {
      get
      set(newValue)
    }
    private var _deleteRealmIfMigrationNeeded: Swift.Bool = false
    @preconcurrency public var shouldCompactOnLaunch: (@Sendable (Swift.Int, Swift.Int) -> Swift.Bool)?
    public var objectTypes: [RealmSwift.ObjectBase.Type]? {
      get
      set
    }
    public var maximumNumberOfActiveVersions: Swift.UInt?
    public var seedFilePath: Foundation.URL?
    public var eventConfiguration: RealmSwift.EventConfiguration?
    private var customSchema: RLMSchema?
    internal var disableFormatUpgrade: Swift.Bool = false
  }
}
extension RealmSwift.Realm.Configuration : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RealmSwift.Realm.Configuration : Swift.Equatable {
  public static func == (lhs: RealmSwift.Realm.Configuration, rhs: RealmSwift.Realm.Configuration) -> Swift.Bool
}
public protocol RealmKeyedCollection : RealmSwift.ThreadConfined, Swift.CustomStringConvertible, Swift.Sequence {
  associatedtype Key : RealmSwift._MapKey
  associatedtype Value : RealmSwift.RealmCollectionValue
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var count: Swift.Int { get }
  var description: Swift.String { get }
  func updateValue(_ value: Self.Value, forKey key: Self.Key)
  func removeObject(for key: Self.Key)
  func removeAll()
  subscript(key: Self.Key) -> Self.Value? { get set }
  func value(forKey key: Swift.String) -> Swift.AnyObject?
  func value(forKeyPath keyPath: Swift.String) -> Swift.AnyObject?
  func setValue(_ value: Any?, forKey key: Swift.String)
  func filter(_ predicate: Foundation.NSPredicate) -> RealmSwift.Results<Self.Value>
  func contains(where predicate: @escaping (_ key: Self.Key, _ value: Self.Value) -> Swift.Bool) -> Swift.Bool
  func sorted(ascending: Swift.Bool) -> RealmSwift.Results<Self.Value>
  func sorted(byKeyPath keyPath: Swift.String, ascending: Swift.Bool) -> RealmSwift.Results<Self.Value>
  func sorted<S>(by sortDescriptors: S) -> RealmSwift.Results<Self.Value> where S : Swift.Sequence, S.Element == RealmSwift.SortDescriptor
  var keys: [Self.Key] { get }
  var values: [Self.Value] { get }
  func min<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  func max<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  func sum<T>(ofProperty property: Swift.String) -> T where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  func average<T>(ofProperty property: Swift.String) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  func observe(keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.RealmMapChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
}
extension RealmSwift.RealmKeyedCollection {
  public func observe(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.RealmMapChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
}
extension RealmSwift.RealmKeyedCollection where Self.Value : RealmSwift.OptionalProtocol, Self.Value.Wrapped : RLMObjectBase {
  public func min<T>(of keyPath: Swift.KeyPath<Self.Value.Wrapped, T>) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  public func max<T>(of keyPath: Swift.KeyPath<Self.Value.Wrapped, T>) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.MinMaxType
  public func sum<T>(of keyPath: Swift.KeyPath<Self.Value.Wrapped, T>) -> T where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
  public func average<T>(of keyPath: Swift.KeyPath<Self.Value.Wrapped, T>) -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
}
extension RealmSwift.RealmKeyedCollection where Self.Value : RealmSwift.OptionalProtocol, Self.Value.Wrapped : RLMObjectBase, Self.Value.Wrapped : RealmSwift.RealmCollectionValue {
  public func sorted<T>(by keyPath: Swift.KeyPath<Self.Value.Wrapped, T>, ascending: Swift.Bool) -> RealmSwift.Results<Self.Value> where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.SortableType
}
extension RealmSwift.RealmKeyedCollection where Self.Value.PersistedType : RealmSwift.MinMaxType {
  public func min() -> Self.Value?
  public func max() -> Self.Value?
}
extension RealmSwift.RealmKeyedCollection where Self.Value.PersistedType : RealmSwift.AddableType {
  public func sum() -> Self.Value
  public func average<T>() -> T? where T : RealmSwift._HasPersistedType, T.PersistedType : RealmSwift.AddableType
}
extension RealmSwift.RealmKeyedCollection where Self.Value.PersistedType : RealmSwift.SortableType {
  public func sorted(ascending: Swift.Bool = true) -> RealmSwift.Results<Self.Value>
}
@_inheritsConvenienceInitializers final public class RealmProperty<Value> : RLMSwiftValueStorage where Value : RealmSwift.RealmPropertyType {
  final public var value: Value {
    get
    set
  }
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
extension RealmSwift.RealmProperty : Swift.Equatable where Value : Swift.Equatable {
  public static func == (lhs: RealmSwift.RealmProperty<Value>, rhs: RealmSwift.RealmProperty<Value>) -> Swift.Bool
}
extension RealmSwift.RealmProperty : Swift.Codable where Value : Swift.Decodable, Value : Swift.Encodable {
  convenience public init(from decoder: any Swift.Decoder) throws
  final public func encode(to encoder: any Swift.Encoder) throws
}
public protocol RealmPropertyType : RealmSwift._ObjcBridgeable, RealmSwift._RealmSchemaDiscoverable {
}
extension RealmSwift.AnyRealmValue : RealmSwift.RealmPropertyType {
}
extension Swift.Optional : RealmSwift.RealmPropertyType where Wrapped : RealmSwift.RealmOptionalType, Wrapped : RealmSwift._RealmSchemaDiscoverable {
}
@_marker public protocol MinMaxType {
}
extension Foundation.NSNumber : RealmSwift.MinMaxType {
}
extension Swift.Double : RealmSwift.MinMaxType {
}
extension Swift.Float : RealmSwift.MinMaxType {
}
extension Swift.Int : RealmSwift.MinMaxType {
}
extension Swift.Int8 : RealmSwift.MinMaxType {
}
extension Swift.Int16 : RealmSwift.MinMaxType {
}
extension Swift.Int32 : RealmSwift.MinMaxType {
}
extension Swift.Int64 : RealmSwift.MinMaxType {
}
extension Foundation.Date : RealmSwift.MinMaxType {
}
extension Foundation.NSDate : RealmSwift.MinMaxType {
}
extension RealmSwift.Decimal128 : RealmSwift.MinMaxType {
}
extension RealmSwift.AnyRealmValue : RealmSwift.MinMaxType {
}
extension Swift.Optional : RealmSwift.MinMaxType where Wrapped : RealmSwift.MinMaxType {
}
@_marker public protocol AddableType {
}
extension Foundation.NSNumber : RealmSwift.AddableType {
}
extension Swift.Double : RealmSwift.AddableType {
}
extension Swift.Float : RealmSwift.AddableType {
}
extension Swift.Int : RealmSwift.AddableType {
}
extension Swift.Int8 : RealmSwift.AddableType {
}
extension Swift.Int16 : RealmSwift.AddableType {
}
extension Swift.Int32 : RealmSwift.AddableType {
}
extension Swift.Int64 : RealmSwift.AddableType {
}
extension RealmSwift.Decimal128 : RealmSwift.AddableType {
}
extension RealmSwift.AnyRealmValue : RealmSwift.AddableType {
}
extension Swift.Optional : RealmSwift.AddableType where Wrapped : RealmSwift.AddableType {
}
@_marker public protocol SortableType {
}
extension RealmSwift.AnyRealmValue : RealmSwift.SortableType {
}
extension Foundation.Data : RealmSwift.SortableType {
}
extension Foundation.Date : RealmSwift.SortableType {
}
extension RealmSwift.Decimal128 : RealmSwift.SortableType {
}
extension Swift.Double : RealmSwift.SortableType {
}
extension Swift.Float : RealmSwift.SortableType {
}
extension Swift.Int16 : RealmSwift.SortableType {
}
extension Swift.Int32 : RealmSwift.SortableType {
}
extension Swift.Int64 : RealmSwift.SortableType {
}
extension Swift.Int8 : RealmSwift.SortableType {
}
extension Swift.Int : RealmSwift.SortableType {
}
extension Swift.String : RealmSwift.SortableType {
}
extension Swift.Optional : RealmSwift.SortableType where Wrapped : RealmSwift.SortableType {
}
@_marker public protocol KeypathSortable {
}
extension RLMObjectBase : RealmSwift.KeypathSortable {
}
extension RealmSwift.Projection : RealmSwift.KeypathSortable {
}
@frozen public struct Results<Element> : Swift.Equatable where Element : RealmSwift.RealmCollectionValue {
  internal let collection: any RLMCollection
  public var description: Swift.String {
    get
  }
  public subscript(position: Swift.Int) -> Element {
    get
  }
  public static func == (lhs: RealmSwift.Results<Element>, rhs: RealmSwift.Results<Element>) -> Swift.Bool
  public func makeIterator() -> RealmSwift.RLMIterator<Element>
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func subscribe(name: Swift.String? = nil, waitForSync: WaitForSyncMode = .onCreation, timeout: Foundation.TimeInterval? = nil, _isolation: isolated any _Concurrency.Actor = #isolation) async throws -> RealmSwift.Results<Element>
  public func unsubscribe()
  public typealias Elements = RealmSwift.Results<Element>
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.RLMIterator<Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.Results<Element>>
}
extension RealmSwift.Results : Swift.Encodable where Element : Swift.Encodable {
}
extension RLMRealm {
  @nonobjc public class func schemaVersion(at url: Foundation.URL, usingEncryptionKey key: Foundation.Data? = nil) throws -> Swift.UInt64
  @nonobjc public func resolve<Confined>(reference: RLMThreadSafeReference<Confined>) -> Confined? where Confined : RLMThreadConfined
}
extension RLMObject {
  public class func objects(where predicateFormat: Swift.String, _ args: any Swift.CVarArg...) -> RLMResults<RLMObject>
  public class func objects(in realm: RLMRealm, where predicateFormat: Swift.String, _ args: any Swift.CVarArg...) -> RLMResults<RLMObject>
}
public protocol _RLMCollectionIterator : Swift.Sequence {
  func makeIterator() -> RealmSwift.RLMCollectionIterator
}
extension RealmSwift._RLMCollectionIterator where Self : RLMCollection {
  public func makeIterator() -> RealmSwift.RLMCollectionIterator
}
public typealias RLMDictionarySingleEntry = (key: Swift.String, value: RLMObject)
public protocol _RLMDictionaryIterator {
  func makeIterator() -> RealmSwift.RLMDictionaryIterator
}
extension RealmSwift._RLMDictionaryIterator where Self : RLMCollection {
  public func makeIterator() -> RealmSwift.RLMDictionaryIterator
}
extension RLMArray : @retroactive Swift.Sequence, RealmSwift._RLMCollectionIterator {
  public typealias Element = RLMObject
  public typealias Iterator = RealmSwift.RLMCollectionIterator
}
extension RLMDictionary : @retroactive Swift.Sequence, RealmSwift._RLMDictionaryIterator {
  public typealias Element = RealmSwift.RLMDictionarySingleEntry
  public typealias Iterator = RealmSwift.RLMDictionaryIterator
}
extension RLMSet : @retroactive Swift.Sequence, RealmSwift._RLMCollectionIterator {
  public typealias Element = RLMObject
  public typealias Iterator = RealmSwift.RLMCollectionIterator
}
extension RLMResults : @retroactive Swift.Sequence, RealmSwift._RLMCollectionIterator {
  public typealias Element = RLMObject
  public typealias Iterator = RealmSwift.RLMCollectionIterator
}
public struct RLMCollectionIterator : Swift.IteratorProtocol {
  public mutating func next() -> RLMObject?
  public typealias Element = RLMObject
}
public struct RLMDictionaryIterator : Swift.IteratorProtocol {
  public mutating func next() -> RealmSwift.RLMDictionarySingleEntry?
  public typealias Element = RealmSwift.RLMDictionarySingleEntry
}
extension RLMCollection {
  public func indexOfObject(where predicateFormat: Swift.String, _ args: any Swift.CVarArg...) -> Swift.UInt
  public func objects(where predicateFormat: Swift.String, _ args: any Swift.CVarArg...) -> RLMResults<ObjectiveC.NSObject>
}
extension RLMCollection {
  public subscript(key: Swift.String) -> Swift.AnyObject? {
    get
    set
  }
}
@frozen public struct Schema : Swift.CustomStringConvertible {
  internal let rlmSchema: RLMSchema
  public var objectSchema: [RealmSwift.ObjectSchema] {
    get
  }
  public var description: Swift.String {
    get
  }
  public subscript(className: Swift.String) -> RealmSwift.ObjectSchema? {
    get
  }
}
extension RealmSwift.Schema : Swift.Equatable {
  public static func == (lhs: RealmSwift.Schema, rhs: RealmSwift.Schema) -> Swift.Bool
}
public protocol _RealmSchemaDiscoverable {
  static var _rlmType: RealmSwift.PropertyType { get }
  static var _rlmOptional: Swift.Bool { get }
  static var _rlmRequireObjc: Swift.Bool { get }
  func _rlmPopulateProperty(_ prop: RLMProperty)
  static func _rlmPopulateProperty(_ prop: RLMProperty)
}
extension RLMObjectBase {
  @_spi(RealmSwiftPrivate) @objc dynamic open class func _customRealmProperties() -> [RLMProperty]?
}
extension RLMProperty {
  @_spi(RealmSwiftPrivate) convenience public init<O, V>(name: Swift.String, objectType _: O.Type, valueType _: V.Type, indexed: Swift.Bool = false, primaryKey: Swift.Bool = false, originProperty: Swift.String? = nil) where O : RLMObjectBase, V : RealmSwift._Persistable
}
public protocol RealmSectionedResult : RealmSwift.ThreadConfined, Swift.Equatable, Swift.RandomAccessCollection {
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var count: Swift.Int { get }
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
  func observe(keyPaths: [Swift.String]?, on queue: Dispatch.DispatchQueue?, _ block: @escaping (RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
}
extension RealmSwift.RealmSectionedResult {
  public func observe(keyPaths: [Swift.String]? = nil, on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.String]? = nil, on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
}
extension RealmSwift.RealmSectionedResult where Self.Element : RealmSwift.RealmSectionedResult, Self.Element.Element : RLMObjectBase {
  public func observe(keyPaths: [Swift.PartialKeyPath<Self.Element.Element>], on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.PartialKeyPath<Self.Element.Element>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
}
extension RealmSwift.RealmSectionedResult where Self.Element : RLMObjectBase {
  public func observe(keyPaths: [Swift.PartialKeyPath<Self.Element>], on queue: Dispatch.DispatchQueue? = nil, _ block: @escaping (RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) -> RealmSwift.NotificationToken
  @available(macOS 10.15, tvOS 13.0, iOS 13.0, watchOS 6.0, *)
  public func observe<A>(keyPaths: [Swift.PartialKeyPath<Self.Element>], on actor: A, _isolation: isolated (any _Concurrency.Actor)? = #isolation, _ block: @escaping @Sendable (isolated A, RealmSwift.SectionedResultsChange<Self>) -> Swift.Void) async -> RealmSwift.NotificationToken where A : _Concurrency.Actor
}
public struct SectionedResults<Key, SectionElement> where Key : RealmSwift._Persistable, Key : Swift.Hashable, SectionElement : RealmSwift.RealmCollectionValue {
  public typealias Element = RealmSwift.ResultsSection<Key, SectionElement>
  public var allKeys: [Key] {
    get
  }
  public subscript(index: Swift.Int) -> RealmSwift.SectionedResults<Key, SectionElement>.Element {
    get
  }
  public subscript(indexPath: Foundation.IndexPath) -> SectionElement {
    get
  }
  public func makeIterator() -> RealmSwift.SectionedResultsIterator<Key, SectionElement>
  public static func == (lhs: RealmSwift.SectionedResults<Key, SectionElement>, rhs: RealmSwift.SectionedResults<Key, SectionElement>) -> Swift.Bool
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.SectionedResultsIterator<Key, SectionElement>
  public typealias SubSequence = Swift.Slice<RealmSwift.SectionedResults<Key, SectionElement>>
}
public struct ResultsSection<Key, T> where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RealmSwift.RealmCollectionValue {
  public typealias Element = T
  public var key: Key {
    get
  }
  public var id: Key {
    get
  }
  public subscript(index: Swift.Int) -> T {
    get
  }
  public func makeIterator() -> RealmSwift.SectionIterator<RealmSwift.ResultsSection<Key, T>.Element>
  public static func == (lhs: RealmSwift.ResultsSection<Key, RealmSwift.ResultsSection<Key, T>.Element>, rhs: RealmSwift.ResultsSection<Key, RealmSwift.ResultsSection<Key, T>.Element>) -> Swift.Bool
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias Iterator = RealmSwift.SectionIterator<RealmSwift.ResultsSection<Key, T>.Element>
  public typealias SubSequence = Swift.Slice<RealmSwift.ResultsSection<Key, T>>
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension RealmSwift.ResultsSection : Swift.Identifiable {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ID = Key
}
@frozen public enum SectionedResultsChange<Collection> {
  case initial(Collection)
  case update(Collection, deletions: [Foundation.IndexPath], insertions: [Foundation.IndexPath], modifications: [Foundation.IndexPath], sectionsToInsert: Foundation.IndexSet, sectionsToDelete: Foundation.IndexSet)
}
@available(*, deprecated, renamed: "SectionedResultsChange")
public typealias RealmSectionedResultsChange = RealmSwift.SectionedResultsChange
@frozen public struct SectionedResultsIterator<Key, Element> : Swift.IteratorProtocol where Key : RealmSwift._Persistable, Key : Swift.Hashable, Element : RealmSwift.RealmCollectionValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  public mutating func next() -> RealmSwift.ResultsSection<Key, Element>?
}
@available(*, deprecated, renamed: "SectionedResultsIterator")
public typealias RLMSectionedResultsIterator = RealmSwift.SectionedResultsIterator
@frozen public struct SectionIterator<Element> : Swift.IteratorProtocol where Element : RealmSwift.RealmCollectionValue {
  private var generatorBase: Foundation.NSFastEnumerationIterator
  public mutating func next() -> Element?
}
@available(*, deprecated, renamed: "SectionIterator")
public typealias RLMSectionIterator = RealmSwift.SectionIterator
@frozen public struct SortDescriptor {
  public let keyPath: Swift.String
  public let ascending: Swift.Bool
  public init(keyPath: Swift.String, ascending: Swift.Bool = true)
  public init<Element>(keyPath: Swift.PartialKeyPath<Element>, ascending: Swift.Bool = true) where Element : RLMObjectBase
  public func reversed() -> RealmSwift.SortDescriptor
}
extension RealmSwift.SortDescriptor : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension RealmSwift.SortDescriptor : Swift.Equatable {
  public static func == (lhs: RealmSwift.SortDescriptor, rhs: RealmSwift.SortDescriptor) -> Swift.Bool
}
extension RealmSwift.SortDescriptor : Swift.ExpressibleByStringLiteral {
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor @propertyWrapper public struct StateRealmObject<T> : SwiftUICore.DynamicProperty where T : RealmSwift.RealmSubscribable, T : RealmSwift.ThreadConfined, T : Swift.Equatable {
  @_Concurrency.MainActor public var wrappedValue: T {
    get
    nonmutating set
  }
  @_Concurrency.MainActor public var projectedValue: SwiftUICore.Binding<T> {
    get
  }
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @_Concurrency.MainActor public init<Value>(wrappedValue: T) where T == RealmSwift.List<Value>, Value : RealmSwift.RealmCollectionValue
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @_Concurrency.MainActor public init<Value>(wrappedValue: T) where T == RealmSwift.MutableSet<Value>, Value : RealmSwift.RealmCollectionValue
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @_Concurrency.MainActor public init<Key, Value>(wrappedValue: T) where T == RealmSwift.Map<Key, Value>, Key : RealmSwift._MapKey, Value : RealmSwift.RealmCollectionValue
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @_Concurrency.MainActor public init(wrappedValue: T) where T : RLMObjectBase, T : Swift.Identifiable
  @available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
  @_Concurrency.MainActor public init(wrappedValue: T) where T : RealmSwift.ProjectionObservable
  @_Concurrency.MainActor public var _publisher: some Combine.Publisher {
    get
  }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol _ObservedResultsValue : RealmSwift.RealmCollectionValue {
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwiftObject : RealmSwift._ObservedResultsValue {
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Projection : RealmSwift._ObservedResultsValue {
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper @_Concurrency.MainActor @preconcurrency public struct ObservedResults<ResultType> : SwiftUICore.DynamicProperty, RealmSwift.BoundCollection where ResultType : RealmSwift.KeypathSortable, ResultType : RealmSwift.RealmFetchable, ResultType : RealmSwift._ObservedResultsValue, ResultType : Swift.Identifiable {
  public typealias Element = ResultType
  @SwiftUICore.State @_projectedValueProperty($filter) @_Concurrency.MainActor @preconcurrency public var filter: Foundation.NSPredicate? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var $filter: SwiftUICore.Binding<Foundation.NSPredicate?> {
    get
  }
  @SwiftUICore.State @_projectedValueProperty($where) @_Concurrency.MainActor @preconcurrency public var `where`: ((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var $where: SwiftUICore.Binding<((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)?> {
    get
  }
  @SwiftUICore.State @_projectedValueProperty($sortDescriptor) @_Concurrency.MainActor @preconcurrency public var sortDescriptor: RealmSwift.SortDescriptor? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var $sortDescriptor: SwiftUICore.Binding<RealmSwift.SortDescriptor?> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var wrappedValue: RealmSwift.Results<ResultType> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var projectedValue: RealmSwift.ObservedResults<ResultType> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public init<ObjectType>(_ type: ResultType.Type, configuration: RealmSwift.Realm.Configuration? = nil, filter: Foundation.NSPredicate? = nil, keyPaths: [Swift.String]? = nil, sortDescriptor: RealmSwift.SortDescriptor? = nil) where ResultType : RealmSwift.Projection<ObjectType>, ObjectType : RLMObjectBase, ObjectType : RealmSwift.RealmCollectionValue, ObjectType : RealmSwift.ThreadConfined
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, configuration: RealmSwift.Realm.Configuration? = nil, filter: Foundation.NSPredicate? = nil, keyPaths: [Swift.String]? = nil, sortDescriptor: RealmSwift.SortDescriptor? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, configuration: RealmSwift.Realm.Configuration? = nil, where: ((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)? = nil, keyPaths: [Swift.String]? = nil, sortDescriptor: RealmSwift.SortDescriptor? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil, sortDescriptor: RealmSwift.SortDescriptor? = nil) where ResultType : RealmSwiftObject
  nonisolated public func update()
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Value = RealmSwift.Results<ResultType>
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@propertyWrapper @_Concurrency.MainActor @preconcurrency public struct ObservedSectionedResults<Key, ResultType> : SwiftUICore.DynamicProperty, RealmSwift.BoundCollection where Key : RealmSwift._Persistable, Key : Swift.Hashable, ResultType : RealmSwift.KeypathSortable, ResultType : RealmSwift.RealmFetchable, ResultType : RealmSwift._ObservedResultsValue, ResultType : Swift.Identifiable {
  public typealias Element = ResultType
  @SwiftUICore.State @_projectedValueProperty($filter) @_Concurrency.MainActor @preconcurrency public var filter: Foundation.NSPredicate? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var $filter: SwiftUICore.Binding<Foundation.NSPredicate?> {
    get
  }
  @SwiftUICore.State @_projectedValueProperty($where) @_Concurrency.MainActor @preconcurrency public var `where`: ((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)? {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var $where: SwiftUICore.Binding<((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)?> {
    get
  }
  @SwiftUICore.State @_projectedValueProperty($sortDescriptors) @_Concurrency.MainActor @preconcurrency public var sortDescriptors: [RealmSwift.SortDescriptor] {
    get
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    nonmutating set
  }
  @_Concurrency.MainActor @preconcurrency public var $sortDescriptors: SwiftUICore.Binding<[RealmSwift.SortDescriptor]> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var wrappedValue: RealmSwift.SectionedResults<Key, ResultType> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public var projectedValue: RealmSwift.ObservedSectionedResults<Key, ResultType> {
    get
  }
  @_Concurrency.MainActor @preconcurrency public func remove(atOffsets offsets: Foundation.IndexSet, section: RealmSwift.ResultsSection<Key, ResultType>) where ResultType : RLMObjectBase, ResultType : RealmSwift.ThreadConfined
  @_Concurrency.MainActor @preconcurrency public init<ObjectType>(_ type: ResultType.Type, sectionKeyPath: Swift.KeyPath<ResultType, Key>, sortDescriptors: [RealmSwift.SortDescriptor] = [], filter: Foundation.NSPredicate? = nil, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwift.Projection<ObjectType>, ObjectType : RLMObjectBase, ObjectType : RealmSwift.RealmCollectionValue, ObjectType : RealmSwift.ThreadConfined
  @_Concurrency.MainActor @preconcurrency public init<ObjectType>(_ type: ResultType.Type, sectionBlock: @escaping (ResultType) -> Key, sortDescriptors: [RealmSwift.SortDescriptor] = [], filter: Foundation.NSPredicate? = nil, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwift.Projection<ObjectType>, ObjectType : RLMObjectBase, ObjectType : RealmSwift.RealmCollectionValue, ObjectType : RealmSwift.ThreadConfined
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, sectionKeyPath: Swift.KeyPath<ResultType, Key>, sortDescriptors: [RealmSwift.SortDescriptor] = [], filter: Foundation.NSPredicate? = nil, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, sectionBlock: @escaping (ResultType) -> Key, sortDescriptors: [RealmSwift.SortDescriptor] = [], filter: Foundation.NSPredicate? = nil, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, sectionBlock: @escaping (ResultType) -> Key, sortDescriptors: [RealmSwift.SortDescriptor] = [], where: ((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)? = nil, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, sectionKeyPath: Swift.KeyPath<ResultType, Key>, sortDescriptors: [RealmSwift.SortDescriptor] = [], where: ((RealmSwift.Query<ResultType>) -> RealmSwift.Query<Swift.Bool>)? = nil, keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, sectionKeyPath: Swift.KeyPath<ResultType, Key>, sortDescriptors: [RealmSwift.SortDescriptor] = [], keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwiftObject
  @_Concurrency.MainActor @preconcurrency public init(_ type: ResultType.Type, sectionBlock: @escaping (ResultType) -> Key, sortDescriptors: [RealmSwift.SortDescriptor], keyPaths: [Swift.String]? = nil, configuration: RealmSwift.Realm.Configuration? = nil) where ResultType : RealmSwiftObject
  nonisolated public func update()
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias Value = RealmSwift.SectionedResults<Key, ResultType>
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@_Concurrency.MainActor @propertyWrapper public struct ObservedRealmObject<ObjectType> : SwiftUICore.DynamicProperty where ObjectType : Combine.ObservableObject, ObjectType : RealmSwift.RealmSubscribable, ObjectType : RealmSwift.ThreadConfined, ObjectType : Swift.Equatable {
  @_Concurrency.MainActor @dynamicMemberLookup @frozen public struct Wrapper {
    @_Concurrency.MainActor public var wrappedValue: ObjectType
    @_Concurrency.MainActor public subscript<Subject>(dynamicMember keyPath: Swift.ReferenceWritableKeyPath<ObjectType, Subject>) -> SwiftUICore.Binding<Subject> {
      get
    }
    @_Concurrency.MainActor public subscript<Subject>(dynamicMember keyPath: Swift.ReferenceWritableKeyPath<ObjectType, Subject>) -> SwiftUICore.Binding<Subject> where Subject : Swift.Equatable {
      get
    }
    @_Concurrency.MainActor public subscript<Subject>(dynamicMember keyPath: Swift.ReferenceWritableKeyPath<ObjectType, Subject>) -> SwiftUICore.Binding<Subject> where Subject : RLMSwiftCollectionBase, Subject : RealmSwift.ThreadConfined {
      get
    }
  }
  @_Concurrency.MainActor public var wrappedValue: ObjectType {
    get
    set
  }
  @_Concurrency.MainActor public var projectedValue: RealmSwift.ObservedRealmObject<ObjectType>.Wrapper {
    get
  }
  @_Concurrency.MainActor public init(wrappedValue: ObjectType) where ObjectType : RLMObjectBase, ObjectType : Swift.Identifiable
  @_Concurrency.MainActor public init<V>(wrappedValue: ObjectType) where ObjectType == RealmSwift.List<V>, V : RealmSwift.RealmCollectionValue
  @_Concurrency.MainActor public init(wrappedValue: ObjectType) where ObjectType : RealmSwift.ProjectionObservable
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SwiftUICore.Binding where Value : RLMObjectBase, Value : RealmSwift.ThreadConfined {
  @_Concurrency.MainActor public subscript<V>(dynamicMember member: Swift.ReferenceWritableKeyPath<Value, V>) -> SwiftUICore.Binding<V> where V : RealmSwift._Persistable {
    get
  }
  @_Concurrency.MainActor public subscript<V>(dynamicMember member: Swift.ReferenceWritableKeyPath<Value, V>) -> SwiftUICore.Binding<V> where V : RLMSwiftCollectionBase, V : RealmSwift.ThreadConfined, V : RealmSwift._Persistable {
    get
  }
  @_Concurrency.MainActor public subscript<V>(dynamicMember member: Swift.ReferenceWritableKeyPath<Value, V>) -> SwiftUICore.Binding<V> where V : RealmSwift._Persistable, V : Swift.Equatable {
    get
  }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
@preconcurrency @_Concurrency.MainActor public protocol BoundCollection {
  associatedtype Value
  associatedtype Element : RealmSwift.RealmCollectionValue
  @_Concurrency.MainActor @preconcurrency var wrappedValue: Self.Value { get }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Value : RealmSwift.RealmCollection {
  public typealias Element = Self.Value.Element
  public typealias Index = Self.Value.Index
  public typealias Indices = Self.Value.Indices
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Value == RealmSwift.List<Self.Element> {
  @_Concurrency.MainActor @preconcurrency public func remove(at index: Self.Index)
  @_Concurrency.MainActor @preconcurrency public func remove(atOffsets offsets: Foundation.IndexSet)
  @_Concurrency.MainActor @preconcurrency public func move(fromOffsets offsets: Foundation.IndexSet, toOffset destination: Swift.Int)
  @_Concurrency.MainActor @preconcurrency public func append(_ value: RealmSwift.List<Self.Element>.Element)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Element : RLMObjectBase, Self.Element : RealmSwift.ThreadConfined, Self.Value == RealmSwift.List<Self.Element> {
  @_Concurrency.MainActor @preconcurrency public func append(_ value: RealmSwift.List<Self.Element>.Element)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Element : RLMObjectBase, Self.Element : RealmSwift.ThreadConfined, Self.Value == RealmSwift.Results<Self.Element> {
  @_Concurrency.MainActor @preconcurrency public func remove(_ object: RealmSwift.Results<Self.Element>.Element)
  @_Concurrency.MainActor @preconcurrency public func remove(atOffsets offsets: Foundation.IndexSet)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Value == RealmSwift.MutableSet<Self.Element> {
  @_Concurrency.MainActor @preconcurrency public func remove(_ element: RealmSwift.MutableSet<Self.Element>.Element)
  @_Concurrency.MainActor @preconcurrency public func insert(_ value: RealmSwift.MutableSet<Self.Element>.Element)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Element : RLMObjectBase, Self.Element : RealmSwift.ThreadConfined, Self.Value == RealmSwift.MutableSet<Self.Element> {
  @_Concurrency.MainActor @preconcurrency public func remove(_ object: RealmSwift.MutableSet<Self.Element>.Element)
  @_Concurrency.MainActor @preconcurrency public func insert(_ value: RealmSwift.MutableSet<Self.Element>.Element)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Element : RealmSwiftObject, Self.Value == RealmSwift.Results<Self.Element> {
  @_Concurrency.MainActor @preconcurrency public func append(_ value: RealmSwift.Results<Self.Element>.Element)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundCollection where Self.Element : RealmSwift.ProjectionObservable, Self.Value == RealmSwift.Results<Self.Element>, Self.Element.Root : RealmSwiftObject {
  @_Concurrency.MainActor @preconcurrency public func append(_ value: RealmSwift.Results<Self.Element>.Element)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Binding : RealmSwift.BoundCollection where Value : RealmSwift.RealmCollection {
  public typealias Element = Value.Element
  public typealias Index = Value.Index
  public typealias Indices = Value.Indices
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
public protocol BoundMap {
  associatedtype Value : RealmSwift.RealmKeyedCollection
  var wrappedValue: Self.Value { get }
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundMap {
  public subscript(key: Self.Value.Key) -> Self.Value.Value? {
    get
  }
  public func set(object: Self.Value.Value?, for key: Self.Value.Key)
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.BoundMap where Self.Value.Value : RLMObjectBase, Self.Value.Value : RealmSwift.ThreadConfined {
  public func set(object: Self.Value.Value?, for key: Self.Value.Key)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Binding : RealmSwift.BoundMap where Value : RealmSwift.RealmKeyedCollection {
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Binding where Value : RealmSwiftObject {
  public func delete()
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension SwiftUICore.Binding where Value : RealmSwift.ProjectionObservable, Value.Root : RealmSwift.ThreadConfined {
  public func delete()
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ThreadConfined where Self : RealmSwift.ProjectionObservable {
  @_Concurrency.MainActor public func bind<V>(_ keyPath: Swift.ReferenceWritableKeyPath<Self, V>) -> SwiftUICore.Binding<V> where V : RealmSwift._Persistable, V : Swift.Equatable
  @_Concurrency.MainActor public func bind<V>(_ keyPath: Swift.ReferenceWritableKeyPath<Self, V>) -> SwiftUICore.Binding<V> where V : RLMSwiftCollectionBase, V : RealmSwift.ThreadConfined, V : RealmSwift._Persistable
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ObservedRealmObject.Wrapper where ObjectType : RLMObjectBase {
  @_Concurrency.MainActor public func delete()
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ThreadConfined where Self : RLMObjectBase {
  @_Concurrency.MainActor public func bind<V>(_ keyPath: Swift.ReferenceWritableKeyPath<Self, V>) -> SwiftUICore.Binding<V> where V : RealmSwift._Persistable, V : Swift.Equatable
  @_Concurrency.MainActor public func bind<V>(_ keyPath: Swift.ReferenceWritableKeyPath<Self, V>) -> SwiftUICore.Binding<V> where V : RLMSwiftCollectionBase, V : RealmSwift.ThreadConfined, V : RealmSwift._Persistable
}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension SwiftUICore.EnvironmentValues {
  public var realmConfiguration: RealmSwift.Realm.Configuration {
    get
    set
  }
  public var realm: RealmSwift.Realm {
    get
    set
  }
  public var partitionValue: (any RealmSwift.PartitionValue)? {
    get
    set
  }
}
public enum AsyncOpenState {
  case connecting
  case waitingForUser
  case open(RealmSwift.Realm)
  case progress(Foundation.Progress)
  case error(any Swift.Error)
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor @propertyWrapper public struct AsyncOpen : SwiftUICore.DynamicProperty {
  @_Concurrency.MainActor public var projectedValue: Combine.Published<RealmSwift.AsyncOpenState>.Publisher {
    get
  }
  @_Concurrency.MainActor public var wrappedValue: RealmSwift.AsyncOpenState {
    get
  }
  @_Concurrency.MainActor public func cancel()
  @_Concurrency.MainActor public init<Partition>(appId: Swift.String? = nil, partitionValue: Partition, configuration: RealmSwift.Realm.Configuration? = nil, timeout: Swift.UInt? = nil) where Partition : RealmSwift.BSON
  @_Concurrency.MainActor public init(appId: Swift.String? = nil, configuration: RealmSwift.Realm.Configuration? = nil, timeout: Swift.UInt? = nil)
  nonisolated public func update()
}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
@_Concurrency.MainActor @propertyWrapper public struct AutoOpen : SwiftUICore.DynamicProperty {
  @_Concurrency.MainActor public var projectedValue: Combine.Published<RealmSwift.AsyncOpenState>.Publisher {
    get
  }
  @_Concurrency.MainActor public var wrappedValue: RealmSwift.AsyncOpenState {
    get
  }
  @_Concurrency.MainActor public func cancel()
  @_Concurrency.MainActor public init<Partition>(appId: Swift.String? = nil, partitionValue: Partition, configuration: RealmSwift.Realm.Configuration? = nil, timeout: Swift.UInt? = nil) where Partition : RealmSwift.BSON
  @_Concurrency.MainActor public init(appId: Swift.String? = nil, configuration: RealmSwift.Realm.Configuration? = nil, timeout: Swift.UInt? = nil)
  nonisolated public func update()
}
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SwiftUICore.View {
  @_Concurrency.MainActor @preconcurrency public func searchable<T>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedResults<T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.Text? = nil) -> some SwiftUICore.View where T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable
  
  @_Concurrency.MainActor @preconcurrency public func searchable<T>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedResults<T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.LocalizedStringKey) -> some SwiftUICore.View where T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable
  
  @_Concurrency.MainActor @preconcurrency public func searchable<T, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedResults<T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: S) -> some SwiftUICore.View where T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, S : Swift.StringProtocol
  
  @_Concurrency.MainActor @preconcurrency public func searchable<T, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedResults<T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.Text? = nil, @SwiftUICore.ViewBuilder suggestions: () -> S) -> some SwiftUICore.View where T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, S : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func searchable<T, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedResults<T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.LocalizedStringKey, @SwiftUICore.ViewBuilder suggestions: () -> S) -> some SwiftUICore.View where T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, S : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func searchable<T, V, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedResults<T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: S, @SwiftUICore.ViewBuilder suggestions: () -> V) -> some SwiftUICore.View where T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, V : SwiftUICore.View, S : Swift.StringProtocol
  
  @_Concurrency.MainActor @preconcurrency public func searchable<Key, T>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedSectionedResults<Key, T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.Text? = nil) -> some SwiftUICore.View where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable
  
  @_Concurrency.MainActor @preconcurrency public func searchable<Key, T>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedSectionedResults<Key, T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.LocalizedStringKey) -> some SwiftUICore.View where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable
  
  @_Concurrency.MainActor @preconcurrency public func searchable<Key, T, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedSectionedResults<Key, T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: S) -> some SwiftUICore.View where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, S : Swift.StringProtocol
  
  @_Concurrency.MainActor @preconcurrency public func searchable<Key, T, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedSectionedResults<Key, T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.Text? = nil, @SwiftUICore.ViewBuilder suggestions: () -> S) -> some SwiftUICore.View where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, S : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func searchable<Key, T, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedSectionedResults<Key, T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: SwiftUICore.LocalizedStringKey, @SwiftUICore.ViewBuilder suggestions: () -> S) -> some SwiftUICore.View where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, S : SwiftUICore.View
  
  @_Concurrency.MainActor @preconcurrency public func searchable<Key, T, V, S>(text: SwiftUICore.Binding<Swift.String>, collection: RealmSwift.ObservedSectionedResults<Key, T>, keyPath: Swift.KeyPath<T, Swift.String>, placement: SwiftUI.SearchFieldPlacement = .automatic, prompt: S, @SwiftUICore.ViewBuilder suggestions: () -> V) -> some SwiftUICore.View where Key : RealmSwift._Persistable, Key : Swift.Hashable, T : RLMObjectBase, T : RealmSwift.RealmFetchable, T : RealmSwift._ObservedResultsValue, T : Swift.Identifiable, V : SwiftUICore.View, S : Swift.StringProtocol
  
}
public typealias User = RLMUser
extension RLMUser {
  @preconcurrency public func linkUser(credentials: RealmSwift.Credentials, _ completion: @escaping @Sendable (Swift.Result<RealmSwift.User, any Swift.Error>) -> Swift.Void)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func linkUser(credentials: RealmSwift.Credentials) -> Combine.Future<RealmSwift.User, any Swift.Error>
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func linkUser(credentials: RealmSwift.Credentials) async throws -> RealmSwift.User
}
public typealias SyncManager = RLMSyncManager
public typealias SyncTimeoutOptions = RLMSyncTimeoutOptions
extension RLMSyncTimeoutOptions {
  convenience public init(connectTimeout: Swift.UInt? = nil, connectionLingerTime: Swift.UInt? = nil, pingKeepalivePeriod: Swift.UInt? = nil, pongKeepaliveTimeout: Swift.UInt? = nil, fastReconnectLimit: Swift.UInt? = nil)
}
public typealias SyncSession = RLMSyncSession
public typealias ErrorReportingBlock = RLMSyncErrorReportingBlock
public typealias UserCompletionBlock = RLMUserCompletionBlock
public typealias SyncError = RLMSyncError
extension RLMSyncError {
  public typealias ActionToken = RLMSyncErrorActionToken
  public func clientResetInfo() -> (Swift.String, RealmSwift.SyncError.ActionToken)?
  public func deleteRealmUserInfo() -> RealmSwift.SyncError.ActionToken?
  public var serverLogURL: Foundation.URL? {
    get
  }
  public var compensatingWriteInfo: [RealmSwift.CompensatingWriteInfo]? {
    get
  }
}
public typealias CompensatingWriteInfo = RLMCompensatingWriteInfo
extension RLMCompensatingWriteInfo {
  public var primaryKey: RealmSwift.AnyRealmValue {
    get
  }
}
public typealias AppError = RLMAppError
public typealias SyncLogLevel = RLMSyncLogLevel
public typealias Provider = RLMIdentityProvider
@frozen public enum ClientResetMode {
  @available(*, deprecated, message: "Use discardUnsyncedChanges")
  @preconcurrency case discardLocal(beforeReset: (@Sendable (_ before: RealmSwift.Realm) -> Swift.Void)? = nil, afterReset: (@Sendable (_ before: RealmSwift.Realm, _ after: RealmSwift.Realm) -> Swift.Void)? = nil)
  @preconcurrency case discardUnsyncedChanges(beforeReset: (@Sendable (_ before: RealmSwift.Realm) -> Swift.Void)? = nil, afterReset: (@Sendable (_ before: RealmSwift.Realm, _ after: RealmSwift.Realm) -> Swift.Void)? = nil)
  @preconcurrency case recoverUnsyncedChanges(beforeReset: (@Sendable (_ before: RealmSwift.Realm) -> Swift.Void)? = nil, afterReset: (@Sendable (_ before: RealmSwift.Realm, _ after: RealmSwift.Realm) -> Swift.Void)? = nil)
  @preconcurrency case recoverOrDiscardUnsyncedChanges(beforeReset: (@Sendable (_ before: RealmSwift.Realm) -> Swift.Void)? = nil, afterReset: (@Sendable (_ before: RealmSwift.Realm, _ after: RealmSwift.Realm) -> Swift.Void)? = nil)
  @preconcurrency case manual(errorHandler: RealmSwift.ErrorReportingBlock? = nil)
}
public typealias InitialSubscriptionsConfiguration = RLMInitialSubscriptionsConfiguration
@frozen public struct SyncConfiguration : Swift.Sendable {
  public var user: RealmSwift.User {
    get
  }
  public var partitionValue: RealmSwift.AnyBSON? {
    get
  }
  public var clientResetMode: RealmSwift.ClientResetMode {
    get
  }
  public var cancelAsyncOpenOnNonFatalErrors: Swift.Bool {
    get
  }
  public var initialSubscriptions: RealmSwift.InitialSubscriptionsConfiguration? {
    get
  }
  nonisolated(unsafe) internal let config: RLMSyncConfiguration
}
@dynamicMemberLookup @frozen public struct Functions : Swift.Sendable {
  private let user: RealmSwift.User
  public typealias FunctionCompletionHandler = @Sendable (RealmSwift.AnyBSON?, (any Swift.Error)?) -> Swift.Void
  public typealias Function = @Sendable ([RealmSwift.AnyBSON], @escaping RealmSwift.Functions.FunctionCompletionHandler) -> Swift.Void
  public subscript(dynamicMember string: Swift.String) -> RealmSwift.Functions.Function {
    get
  }
  public typealias ResultFunctionCompletionHandler = @Sendable (Swift.Result<RealmSwift.AnyBSON, any Swift.Error>) -> Swift.Void
  public typealias ResultFunction = @Sendable ([RealmSwift.AnyBSON], @escaping RealmSwift.Functions.ResultFunctionCompletionHandler) -> Swift.Void
  @preconcurrency public subscript(dynamicMember string: Swift.String) -> RealmSwift.Functions.ResultFunction {
    get
  }
  public subscript(dynamicMember string: Swift.String) -> RealmSwift.FunctionCallable {
    get
  }
}
@dynamicCallable public struct FunctionCallable : Swift.Sendable {
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  @available(*, deprecated, message: "Specify args separately without wrapping them in an array")
  public func dynamicallyCall(withArguments args: [[RealmSwift.AnyBSON]]) -> Combine.Future<RealmSwift.AnyBSON, any Swift.Error>
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func dynamicallyCall(withArguments args: [RealmSwift.AnyBSON]) -> Combine.Future<RealmSwift.AnyBSON, any Swift.Error>
}
extension RLMUser {
  @preconcurrency public func configuration<T>(partitionValue: T, clientResetMode: RealmSwift.ClientResetMode = .recoverUnsyncedChanges(beforeReset: nil, afterReset: nil), cancelAsyncOpenOnNonFatalErrors: Swift.Bool = false) -> RealmSwift.Realm.Configuration where T : RealmSwift.BSON
  @preconcurrency public func configuration(partitionValue: RealmSwift.AnyBSON, clientResetMode: RealmSwift.ClientResetMode = .recoverUnsyncedChanges(beforeReset: nil, afterReset: nil), cancelAsyncOpenOnNonFatalErrors: Swift.Bool = false) -> RealmSwift.Realm.Configuration
  public var customData: RealmSwift.Document {
    get
  }
  public func mongoClient(_ serviceName: Swift.String) -> RealmSwift.MongoClient
  public var functions: RealmSwift.Functions {
    get
  }
}
extension RLMSyncSession {
  public typealias State = RLMSyncSessionState
  public typealias ConnectionState = RLMSyncConnectionState
  public enum ProgressDirection : Swift.Sendable {
    case upload
    case download
    public static func == (a: RLMSyncSession.ProgressDirection, b: RLMSyncSession.ProgressDirection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ProgressMode : Swift.Sendable {
    case reportIndefinitely
    case forCurrentlyOutstandingWork
    public static func == (a: RLMSyncSession.ProgressMode, b: RLMSyncSession.ProgressMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias ProgressNotificationToken = RLMProgressNotificationToken
  public struct Progress : Swift.Sendable {
    @available(*, deprecated, message: "Use progressEstimate")
    public var transferredBytes: Swift.Int {
      get
    }
    @available(*, deprecated, message: "Use progressEstimate")
    public var transferrableBytes: Swift.Int {
      get
    }
    public let progressEstimate: Swift.Double
    @available(*, deprecated, renamed: "progressEstimate", message: "Use progressEstimate")
    public var fractionTransferred: Swift.Double {
      get
    }
    public var isTransferComplete: Swift.Bool {
      get
    }
  }
  @preconcurrency public func addProgressNotification(for direction: RLMSyncSession.ProgressDirection, mode: RLMSyncSession.ProgressMode, block: @escaping @Sendable (RLMSyncSession.Progress) -> Swift.Void) -> RLMSyncSession.ProgressNotificationToken?
  public func wait(for direction: RLMSyncSession.ProgressDirection, queue: Dispatch.DispatchQueue? = nil, block: @escaping @Sendable ((any Swift.Error)?) -> Swift.Void)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  public func wait(for direction: RLMSyncSession.ProgressDirection) async throws
}
extension RealmSwift.Realm {
  @available(*, unavailable, message: "Use Results.subscribe()")
  public func subscribe<T>(to objects: T.Type, where: Swift.String, completion: @escaping (RealmSwift.Results<T>?, (any Swift.Error)?) -> Swift.Void) where T : RealmSwiftObject
  public var syncSession: RealmSwift.SyncSession? {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMUser {
  public func refreshCustomData() -> Combine.Future<[Swift.AnyHashable : Any], any Swift.Error>
  public func remove() -> Combine.Future<Swift.Void, any Swift.Error>
  public func logOut() -> Combine.Future<Swift.Void, any Swift.Error>
  public func delete() -> Combine.Future<Swift.Void, any Swift.Error>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
@frozen public struct UserSubscription : Combine.Subscription {
  private let token: RLMUserSubscriptionToken
  public var combineIdentifier: Combine.CombineIdentifier {
    get
  }
  public func request(_ demand: Combine.Subscribers.Demand)
  public func cancel()
}
@_hasMissingDesignatedInitializers @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public class UserPublisher : Combine.Publisher {
  public typealias Failure = Swift.Never
  public typealias Output = RealmSwift.User
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == RLMUser
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMUser {
  public var objectWillChange: Combine.AnyPublisher<RealmSwift.UserPublisher.Output, RealmSwift.UserPublisher.Failure> {
    get
  }
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RLMUser : @retroactive Combine.ObservableObject {
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  public typealias ObjectWillChangePublisher = Combine.AnyPublisher<RealmSwift.UserPublisher.Output, RealmSwift.UserPublisher.Failure>
}
extension RLMUser {
  @preconcurrency public func refreshCustomData(_ completion: @escaping @Sendable (Swift.Result<[Swift.AnyHashable : Any], any Swift.Error>) -> Swift.Void)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  @discardableResult
  public func refreshCustomData() async throws -> RealmSwift.Document
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.FunctionCallable {
  @available(*, deprecated, message: "Specify args separately without wrapping them in an array")
  public func dynamicallyCall(withArguments args: [[RealmSwift.AnyBSON]]) async throws -> RealmSwift.AnyBSON
  public func dynamicallyCall(withArguments args: [RealmSwift.AnyBSON]) async throws -> RealmSwift.AnyBSON
}
extension RLMUser {
  public func flexibleSyncConfiguration(clientResetMode: RealmSwift.ClientResetMode = .recoverUnsyncedChanges(), cancelAsyncOpenOnNonFatalErrors: Swift.Bool = false) -> RealmSwift.Realm.Configuration
  @preconcurrency public func flexibleSyncConfiguration(clientResetMode: RealmSwift.ClientResetMode = .recoverUnsyncedChanges(), cancelAsyncOpenOnNonFatalErrors: Swift.Bool = false, initialSubscriptions: @escaping @Sendable (RealmSwift.SyncSubscriptionSet) -> Swift.Void, rerunOnOpen: Swift.Bool = false) -> RealmSwift.Realm.Configuration
}
@frozen public enum SyncSubscriptionState : Swift.Equatable {
  case complete
  case error(any Swift.Error)
  case pending
  case superseded
  public static func == (lhs: RealmSwift.SyncSubscriptionState, rhs: RealmSwift.SyncSubscriptionState) -> Swift.Bool
}
@frozen public struct SyncSubscription {
  fileprivate let _rlmSyncSubscription: RLMSyncSubscription
  public var name: Swift.String? {
    get
  }
  public var createdAt: Foundation.Date {
    get
  }
  public var updatedAt: Foundation.Date {
    get
  }
  public func updateQuery<T>(toType type: T.Type, where query: ((RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>)? = nil) where T : RealmSwiftObject
  public func updateQuery<T>(toType type: T.Type, where query: (RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>) where T : RealmSwiftObject
  @available(*, unavailable, renamed: "updateQuery", message: "SyncSubscription update is unavailable, please use `.updateQuery` instead.")
  public func update<T>(toType type: T.Type, where query: @escaping (RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>) where T : RealmSwiftObject
  public func updateQuery(to predicateFormat: Swift.String, _ args: Any...)
  @available(*, unavailable, renamed: "updateQuery", message: "SyncSubscription update is unavailable, please use `.updateQuery` instead.")
  public func update(to predicateFormat: Swift.String, _ args: Any...)
  public func updateQuery(to predicate: Foundation.NSPredicate)
  @available(*, unavailable, renamed: "updateQuery", message: "SyncSubscription update is unavailable, please use `.updateQuery` instead.")
  public func update(to predicate: Foundation.NSPredicate)
}
@frozen public struct QuerySubscription<T> where T : RealmSwiftObject {
  fileprivate let name: Swift.String?
  fileprivate var className: Swift.String
  fileprivate var predicate: Foundation.NSPredicate
  public typealias QueryFunction = (RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>
  public init(name: Swift.String? = nil)
  public init(name: Swift.String? = nil, query: borrowing (RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>)
  public init(name: Swift.String? = nil, where predicateFormat: Swift.String, _ args: Any...)
  public init(name: Swift.String? = nil, where predicate: Foundation.NSPredicate)
}
@frozen public struct SyncSubscriptionSet {
  internal let rlmSyncSubscriptionSet: RLMSyncSubscriptionSet
  public var count: Swift.Int {
    get
  }
  public func update(_ block: () -> Swift.Void, onComplete: (@Sendable ((any Swift.Error)?) -> Swift.Void)? = nil)
  @available(*, unavailable, renamed: "update", message: "SyncSubscriptionSet write is unavailable, please use `.update` instead.")
  public func write(_ block: () -> Swift.Void, onComplete: (((any Swift.Error)?) -> Swift.Void)? = nil)
  public var state: RealmSwift.SyncSubscriptionState {
    get
  }
  public func first(named: Swift.String) -> RealmSwift.SyncSubscription?
  public func first<T>(ofType type: T.Type, where query: (RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>) -> RealmSwift.SyncSubscription? where T : RealmSwiftObject
  public func first<T>(ofType type: T.Type, where predicateFormat: Swift.String, _ args: Any...) -> RealmSwift.SyncSubscription? where T : RealmSwiftObject
  public func first<T>(ofType type: T.Type, where predicate: Foundation.NSPredicate) -> RealmSwift.SyncSubscription? where T : RealmSwiftObject
  public func append<T>(_ subscriptions: RealmSwift.QuerySubscription<T>...) where T : RealmSwiftObject
  public func remove<T>(ofType type: T.Type, _ query: @escaping (RealmSwift.Query<T>) -> RealmSwift.Query<Swift.Bool>) where T : RealmSwiftObject
  public func remove<T>(ofType type: T.Type, where predicateFormat: Swift.String, _ args: Any...) where T : RealmSwiftObject
  public func remove<T>(ofType type: T.Type, where predicate: Foundation.NSPredicate) where T : RealmSwiftObject
  public func remove(_ subscriptions: RealmSwift.SyncSubscription...)
  public func remove(named: Swift.String)
  public func removeAll(unnamedOnly: Swift.Bool = false)
  public func removeAll<T>(ofType type: T.Type) where T : RealmSwiftObject
  public subscript(position: Swift.Int) -> RealmSwift.SyncSubscription? {
    get
  }
  public var first: RealmSwift.SyncSubscription? {
    get
  }
  public var last: RealmSwift.SyncSubscription? {
    get
  }
}
extension RealmSwift.SyncSubscriptionSet : Swift.Sequence {
  public func makeIterator() -> RealmSwift.SyncSubscriptionSetIterator
  public typealias Element = RLMSyncSubscription
  public typealias Iterator = RealmSwift.SyncSubscriptionSetIterator
}
@frozen public struct SyncSubscriptionSetIterator : Swift.IteratorProtocol {
  private let rlmSubscriptionSet: RLMSyncSubscriptionSet
  private var index: Swift.Int = -1
  public mutating func next() -> RLMSyncSubscription?
  public typealias Element = RLMSyncSubscription
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.SyncSubscriptionSet {
  @_Concurrency.MainActor public func update(_ block: () -> Swift.Void) async throws
  @available(*, unavailable, renamed: "update", message: "SyncSubscriptionSet write is unavailable, please use `.update` instead.")
  public func write(_ block: () -> Swift.Void) async throws
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension RealmSwift.SyncSubscriptionSet {
  public func updateSubscriptions(_ block: @escaping () -> Swift.Void) -> Combine.Future<Swift.Void, any Swift.Error>
}
public protocol ThreadConfined {
  var realm: RealmSwift.Realm? { get }
  var isInvalidated: Swift.Bool { get }
  var isFrozen: Swift.Bool { get }
  func freeze() -> Self
  func thaw() -> Self?
}
@frozen public struct ThreadSafeReference<Confined> where Confined : RealmSwift.ThreadConfined {
  public var isInvalidated: Swift.Bool {
    get
  }
  private let objectiveCReference: RLMThreadSafeReference<any RLMThreadConfined>
  public init(to threadConfined: Confined)
}
@propertyWrapper final public class ThreadSafe<T> where T : RealmSwift.ThreadConfined {
  final public var wrappedValue: T? {
    get
    set
  }
  public init(wrappedValue: T?)
  @objc deinit
}
extension RealmSwift.Realm {
  public func resolve<Confined>(_ reference: RealmSwift.ThreadSafeReference<Confined>) -> Confined? where Confined : RealmSwift.ThreadConfined
}
extension RealmSwift.ThreadSafeReference : Swift.Sendable {
}
extension RLMThreadSafeReference : @unchecked Swift.Sendable {
}
extension RealmSwift.ThreadSafe : @unchecked Swift.Sendable {
}
public func dynamicBridgeCast<T>(fromObjectiveC x: Any) -> T
@usableFromInline
internal func failableDynamicBridgeCast<T>(fromObjectiveC x: Any) -> T?
public func dynamicBridgeCast<T>(fromSwift x: T) -> Any
@usableFromInline
internal func staticBridgeCast<T>(fromSwift x: T) -> Any where T : RealmSwift._ObjcBridgeable
@usableFromInline
internal func staticBridgeCast<T>(fromObjectiveC x: Any) -> T where T : RealmSwift._ObjcBridgeable
@usableFromInline
internal func failableStaticBridgeCast<T>(fromObjectiveC x: Any) -> T? where T : RealmSwift._ObjcBridgeable
extension RLMObjectBase : RealmSwift._ObjcBridgeable {}
extension Swift.Int : RealmSwift._Indexable {}
extension Swift.Int : RealmSwift._PrimaryKey {}
extension Swift.Int : RealmSwift._DefaultConstructible {}
extension Swift.Int : RealmSwift._PersistableInsideOptional {}
extension Swift.Int8 : RealmSwift._Indexable {}
extension Swift.Int8 : RealmSwift._PrimaryKey {}
extension Swift.Int8 : RealmSwift._DefaultConstructible {}
extension Swift.Int8 : RealmSwift._PersistableInsideOptional {}
extension Swift.Int16 : RealmSwift._Indexable {}
extension Swift.Int16 : RealmSwift._PrimaryKey {}
extension Swift.Int16 : RealmSwift._DefaultConstructible {}
extension Swift.Int16 : RealmSwift._PersistableInsideOptional {}
extension Swift.Int32 : RealmSwift._Indexable {}
extension Swift.Int32 : RealmSwift._PrimaryKey {}
extension Swift.Int32 : RealmSwift._DefaultConstructible {}
extension Swift.Int32 : RealmSwift._PersistableInsideOptional {}
extension Swift.Int64 : RealmSwift._Indexable {}
extension Swift.Int64 : RealmSwift._PrimaryKey {}
extension Swift.Int64 : RealmSwift._DefaultConstructible {}
extension Swift.Int64 : RealmSwift._PersistableInsideOptional {}
extension Foundation.NSString : RealmSwift._RealmSchemaDiscoverable {}
extension Foundation.NSData : RealmSwift._RealmSchemaDiscoverable {}
extension Foundation.NSDate : RealmSwift._RealmSchemaDiscoverable {}
extension RealmSwift.List : RealmSwift.RealmCollection {}
extension RealmSwift.MutableSet : RealmSwift.RealmCollection {}
extension RealmSwift.Map : RealmSwift._ObjcBridgeable {}
extension RealmSwift.LinkingObjects : RealmSwift._RealmSchemaDiscoverable {}
extension RealmSwift.LinkingObjects : RealmSwift.RealmCollection {}
extension RealmSwift.Results : RealmSwift.RealmCollection {}
extension RealmSwift.SectionedResults : RealmSwift._ObjcBridgeable {}
extension RealmSwift.SectionedResults : RealmSwift.RealmSectionedResult {}
extension RealmSwift.ResultsSection : RealmSwift._ObjcBridgeable {}
extension RealmSwift.ResultsSection : RealmSwift.RealmSectionedResult {}
extension RealmSwift.AnyRealmCollection : RealmSwift.RealmCollection {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ObservationSubscription : Swift.Sendable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.AsyncOpenSubscription : Swift.Sendable {}
extension RealmSwift.ObjectiveCSupport : Swift.Sendable {}
extension RealmSwift.ObjectiveCSupport : Swift.BitwiseCopyable {}
extension RealmSwift.ObjectSchema : Swift.Sendable {}
extension RealmSwift.Persisted : RealmSwift._RealmSchemaDiscoverable {}
extension RealmSwift.Property : Swift.Sendable {}
extension RealmSwift.Realm.AsyncOpenTask : Swift.Sendable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.Equatable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.Hashable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.RawRepresentable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.Sendable {}
extension RealmSwift.Realm.UpdatePolicy : Swift.BitwiseCopyable {}
extension RealmSwift.Realm.Notification : Swift.Equatable {}
extension RealmSwift.Realm.Notification : Swift.Hashable {}
extension RealmSwift.Realm.Notification : Swift.RawRepresentable {}
extension RealmSwift.Realm.Notification : Swift.Sendable {}
extension RealmSwift.Realm.Notification : Swift.BitwiseCopyable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Realm.OpenBehavior : Swift.Equatable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Realm.OpenBehavior : Swift.Hashable {}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.Realm.OpenBehavior : Swift.BitwiseCopyable {}
extension RealmSwift.Schema : Swift.Sendable {}
extension RealmSwift.SortDescriptor : Swift.Sendable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension RealmSwift.StateRealmObject : Swift.Sendable {}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ObservedResults : Swift.Sendable {}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ObservedSectionedResults : Swift.Sendable {}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ObservedRealmObject : Swift.Sendable {}
@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)
extension RealmSwift.ObservedRealmObject.Wrapper : Swift.Sendable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension RealmSwift.AsyncOpen : Swift.Sendable {}
@available(iOS 14.0, macOS 11.0, tvOS 14.0, watchOS 7.0, *)
extension RealmSwift.AutoOpen : Swift.Sendable {}
extension RealmSwift.ClientResetMode : Swift.Sendable {}
extension RLMSyncSession.ProgressDirection : Swift.Equatable {}
extension RLMSyncSession.ProgressDirection : Swift.Hashable {}
extension RLMSyncSession.ProgressMode : Swift.Equatable {}
extension RLMSyncSession.ProgressMode : Swift.Hashable {}
extension RealmSwift.SyncSubscriptionState : Swift.Sendable {}
